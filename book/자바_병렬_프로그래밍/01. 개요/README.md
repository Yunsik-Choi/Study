# 개요

스레드는 복잡한 비동기 코드를 더 단순한 순차적 코드로 바꿔 복잡한 시스템을 단순하게 개발할 수 있게 해준다.
게다가 멀티프로세서 시스템의 능력을 최대한 끌어낼 수 있는 가장 쉬운 방법이다.

# 1.1 작업을 동시에 실행하는 일에 대한 간략한 역사

운영체제는 여러 개의 프로그램을 각자의 프로세스 내에서 동시에 실행할 수 있도록 발전됐다.
프로세스는 각자가 서로 격리된 채로 독립적으로 실행되는 프로그램으로 운영체제는 프로세스마다 자원을 할당한다.
프로세스끼리는 서로 통신을 할 수도 있는데 소켓, 시그널 핸들러, 공유 메모리, 세마포어, 파일 등의 비교적 큰 단위의 다양한 통신 수단이 제공된다.

- 여러 프로그램을 동시에 실행할 수 있는 운영체제를 개발하게 된 몇 가지 요인
    - 자원 활용 : 프로그램은 때로 입출력과 같이 외부 동작이 끝나기를 기다려야 하는 경우가 많은데 기다리는 동안은 다른 작업을 처리하지 못한다. 따라서 하나의 프로그램이 기다리는 동안 다른 프로그램을
      실행하도록 지원하는 편이 더 효율적이다.
    - 공정성 : 여러 사용자와 프로그램이 컴퓨터 내 자원에 대해 동일한 권한을 가질 수 있다. 한 번에 프로그램 하나를 끝까지 실행해 종료된 이후에야 다른 프로그램을 시작하는 것보다는 더 작은 단위로 컴퓨터를
      공유하는 방법이 바람직하다.
    - 편의성 : 때론 여러 작업을 전부 처리하는 프로그램 하나를 작성하는 것보다 각기 일을 하나씩 처리하고 필요할 때 프로그램 간에 조율하는 프로그램 여러 개를 작성하는 편이 더 쉽고 바람직하다.

자원 활용, 공정성, 편의성 등 프로세스 개념을 만들어내게 된 것과 같은 동기를 갖고 스레드가 고안됐다.
스레드로 인해 한 프로세스 안에 여러 개의 프로그램 제어 흐름이 공존할 수 있다.
스레드는 메모리, 파일 핸들과 같이 프로세스에 할당된 자원을 공유한다.
하지만 각 스레드는 각기 별도의 프로그램 카운터, 스택, 지역 변수를 갖는다.
또한 프로그램을 스레드로 분리하면 멀티 프로세서 시스템에서 자연스럽게 하드웨어 병렬성을 이용할 수 있다.
즉 한 프로그램 내 여러 스레드를 동시에 여러 개의 CPU에 할당해 실행시킬 수 있다.

스레드는 가벼운 프로세스라고 부르기도 하며 현대 운영체제 대부분은 프로세스가 아니라 스레드를 기본 단위로 CPU 자원의 스케줄을 정의한다. 의도적으로 조율하지 않는 한 하나의 스레드는 다른 스레드와 상관 없이
비동기적으로 실행된다.
스레드는 자신이 포함된 프로세스의 메모리 주소 공간을 공유하기 때문에 한 프로세스 내 모든 스레드는 같은 변수에 접근하고 힙에 객체를 할당한다. 이 때문에 프로세스 때보다 더 세밀한 단위로 데이터를 공유할 수 있다.
하지만 공유된 데이터에 접근하는 과정을 적절하게 동기화하지 않으면 다른 스레드가 사용 중인 변수를 순간적으로 수정해 예상치 못한 결과를 얻을 수도 있다.

# 1.2 스레드의 이점

스레드를 제대로 사용하면 개발 및 유지 보수 비용을 줄이고 복잡한 애플리케이션의 성능을 향상시킬 수 있다.
비동기적인 일 흐름을 거의 순차적으로 바꿀 수 있어 사람이 일하고 상호 작용하는 방식을 모델링하기 쉬워진다.
또한 꼬인 코드를 새로 작성해 읽기 쉽고 유지보수하기도 쉬운 명료한 코드로 만들 수도 있다.

스레드는 서버 애플리케이션에서 자원 활용도와 처리율을 높이는 데 유용하다.
또 JVM을 더 단순하게 구현할 수 있도록 도와주기도 한다.
가비지 컬렉터는 보통 하나 또는 두 개 이상의 전용 스레드에서 실행된다.

## 1.2.1 멀티프로세서 활용

프로세서 스케줄링의 기본 단위는 스레드이기 때문에 스레드 하나로 동작하는 프로그램은 한 번에 최대 하나의 프로세서만 사용한다.
프로세서가 두 개인 시스템에서 스레드가 하나뿐인 프로그램을 실행하면 CPU 자원의 50%를 낭비하는 셈이다.
반면에 활성 상태인 스레드가 여러 개인 프로그램은 여러 프로세서에서 동시에 실행될 수 있다.
제대로 설계한다면 멀티 스레드 프로그램은 가용한 프로세서 자원을 더 효율적으로 이용해서 처리 속도를 높일 수 있다.

여러 개의 스레드를 사용하면 프로세서가 하나라 해도 처리 속도를 높일 수 있다.
프로그램이 스레드 하나로 구성되면 동기 I/O 작업이 완료될 때까지 기다리는 동안 프로세서가 놀게 된다.
멀티스레드 프로르램에선 스레드 하나가 I/O가 끝나길 기다리는 동안 다른 스레드가 계속 실행될 수 있다.
즉 I/O 때문에 대기 상태에 들어가는 동안에도 다른 스레드는 동작할 수 있기 때문에 애플리케이션이 계속 실행된다.

## 1.2.2 단순한 모델링

한 종류 일을 순차적으로 처리하는 프로그램은 작성하기 쉽고 오류도 별로 생기지 않는다.
또 여러 종류의 일을 동시에 처리하는 프로그램보다 테스트하기도 쉽다.
종류별 작업마다 또는 시뮬레이션 작업의 각 요소마다 스레드를 하나씩 할당하면 마치 순차적인 작업처럼 처리할 수 있고, 스케줄링, 교차 실행되는 작업, 비동기 I/O, 자원 대기 등의 세부적인 부분과 상위 비즈니스
로직에 해당하는 부분을 분리할 수 있다.
다시 말해 복잡하면서 비동기적인 작업 흐름을 각기 별도 스레드에서 수행되는 더 단순하고 동기적인 작업 흐름 몇 개로 나눌 수 있다.
이런 작업 흐름에서는 특정한 동기화 시점에서만 상호 작용이 발생한다.

이런 장점은 서블릿과 같은 프리임웍에서 종종 활용된다.
프레임웍은 요청 관리, 스레드 생성, 로드 밸런싱, 그리고 작업 흐름 내에서 적절한 시점에 적절한 애플리케이션 컴포넌트에게 요청을 분배하는 등의 상세한 부분을 처리한다.
서블릿 개발자는 동시에 다른 요청이 얼마나 많이 처리되고 있는지 요청이 들어와서 서블릿의 service 메소드가 호출될 때 해당 요청을 마치 단일 스레드 프로그램인 것처럼 처리할 수 있다.
이 때문에 컴포넌트 개발 작업이 훨씬 단순해지고 프레임웍을 쉽게 익힐 수 있다.

## 1.2.3 단순한 비동기 이벤트 처리

여러 클라이언트 프로그램에서 소켓 연결을 받는 서버 애플리케이션의 경우 각 연결마다 스레드를 할당하고 동기 I/O를 사용하도록 하면 개발 작업이 쉬워진다.
읽을 데이터가 없을 때 소켓에서 읽으려고 하면 애플리케이션은 추가 데이터가 들어올 때까지 read 연산에서 대기한다.
이때 스레드가 하나뿐이라면 해당 요청에 대한 작업이 멈추는 것 뿐만 아니라 다른 모든 요청도 처리하지 못하고 멈춘다.
이런 문제를 피하려면 단일 스레드의 경우 복잡한 넌블로킹 I/O 기능을 써야만 한다.
하지만 각 요청을 별개의 스레드에서 처리하면 대기 상태에 들어가도 다른 스레드가 요청을 처리하는 데는 별 영향을 끼치지 않는다.

지금까지의 운영체제는 하나의 프로스세가 생성할 수 있는 스레드 개수에 상대적으로 제약이 심해 최대 수백 개 정도만 생성할 수 있었다.
그러다보니 운영체제에서는 효율적인 다중화 I/O 수단을 개발했고 표준 자바 API에도 대기 상태에 들어가지 않는 I/O를 지원할 수 있도록 java.nio 같은 패키지가 추가됐다.
하지만 시간이 지나면서 운영체제에서 더 많은 스레드를 지원할 수 있게 됨에 따라 일부 플랫폼에서는 다수의 클라이언트에 대해서도 클라이언트마다 스레드를 하나씩 생성하는 경우가 많아졌다.

## 1.2.4 더 빨리 반응하는 사용자 인터페이스

GUI 애플리케이션은 보통 스레드 하나로 동작했다. 모든 애플리케이션 코드를 메인 이벤트 루프를 통해 간접적으로 실행해야 했다.
만약 메인 이벤트 루프에서 직접 호출한 코드가 너무 오래 동안 실행된다면 다음 이벤트를 처리할 수 없이어 사용자 인터페이스가 멈춘 것처럼 보이기도 한다.

스윙과 같은 GUI 프레임웍은 메인 이벤트 루프를 이벤트 전달 스레드로 대체했다.
버튼이 눌리는 등 이벤트가 발생하면 애플리케이션이 정의한 이벤트 핸들러가 이벤트 전달 스레드에서 호출된다.
대부분 GUI 프레임워크는 단일 스레드로 움직이도록 구현되어 있다.
따라서 사실상 메인 이벤트 루프가 여전히 남아있기는 하지만 별도 스레드에서 애플리케이션이 아닌 GUI 툴킷 관할하에 실행된다.

# 1.3 스레드 사용의 위험성

자바 자체에 스레드 관련 기능이 내장되어 있어 병렬 프로그램을 개발하는 일이 쉬워져 스레드를 사용해 작성하는 프로그램이 더 많아졌다.
때문에 개발자라면 스레드 안정성에 대해 잘 알아야 한다.

## 1.3.1 안정성 위해 요소

스레드는 서로 같은 메모리 주소 공간을 공유하고 동시에 실행되기 때문에 다른 스레드가 사용 중일지도 모르는 변수를 읽거나 수정할 수도 있다.
이는 상당히 편리한데 다른 스레드 간 통신 방식보다 데이터 공유가 훨씬 쉽기 때문이다.
하지만 이 점은 위험 요소이기도 하다.
즉 데이터가 예측 못한 시점에 변경돼 스레드가 혼동될 수도 있다.
여러 스레드가 같은 변수를 읽고 수정하게 하면 원래 순차적이던 프로그래밍 모델에 비순차적인 요소가 들어가 혼란스럽고 동작 과정을 추론하기 어려워질 수 있다.
멀티스레드 프로그램이 동작하는 모습을 예측하려면 스레드가 서로 간섭하지 않도록 공유된 변수에 접근하는 시점에 적절하게 조율해야 한다.

동기화를 하지 않으면 컴파일러, 하드웨어, 실행 환경 각각에서 멸령어의 실행 시점이나 실행 순서를 상당히 자유롭게 조정할 수 있다.
레지스터나 다른 스레드에 일시적으로 보이지 않는 프로세서별 캐시 메모리 변수를 캐시해둘 수도 있다.
이런 요령은 성능을 향상하는 데 도움이 되고 바람직하기도 하다.
하지만 프로그래머 입장에선 이런 최적화 작업 때문에 프로그램에 오류가 발생하지 않도록 스레드 간에 데이터가 공유되고 있는지를 명확하게 구분해 줘야 하는 부담을 떠 안아야 한다.

동시 수행 코드를 개발할 때는 반드시 스레드 안정성 문제를 신경 써야 한다.
안정성이 중요한 것은 멀티스레드 프로그램만이 아니다.
단일 스레드 프로그램도 안정성과 정확성을 유지하도록 작성돼야 한다.
하지만 멀티 스레드를 단일 사용하면 단일 스레드 프로그램에서는 발생하지 않는 추가적인 안정성 위험에 노출될 수 있다.

## 1.3.2 활동성 위험

스레드를 사용할 때는 단일 스레드 프로그램에서는 나타나지 않는 추가적인 형태의 활동성 장애가 생길 수 있다.
안정성이 "잘못된 일이 생기지 않는다"는 것을 뜻하는 반면 활동성은 "원하는 일이 결국 일어난다"는 보완적인 목표에 관한 것이다.
어떤 작업이 전혀 진전되지 못하는 상태에 빠질 때 활동성 장애가 발생했다고 한다.
순차적 프로그램에서 생길 수 있는 대표적인 형태는 무한 루프에 빠져 다음에 놓인 코드가 절대 실행되지 않는 경우다.
스레드를 사용하면 활동성 관련 문제의 위험성이 더욱 높아진다.
예를 들어 스레드 A에서 스레드 B가 독점하고 있는 자원을 기다리고 있는데 스레드 B가 해당 자원을 절대 놓지 않는다면 스레드 A는 영영 기다리기만 할 것이다.
대부분의 병렬 프로그램 오류가 그렇지만 활동성 장애를 일으키는 오류 역시 초기에 파악하기가 무척 어렵다.
각기 다른 스레드에서 실행하는 작업의 상대적인 타이밍에 따라 활동성 문제점이 나타나기 때문에 개발이나 테스트 도중에 잘 드러나지 않는다.

## 1.3.3 성능 위험

성능 문제는 서비스 시간, 반응성, 처리율, 자원 소모, 규모에 따른 확장성 등 넓은 범위의 문제를 포괄한다.
멀티스레드 프로그램은 단일 스레드 프로그램에서 발생할 수 있는 모든 성능 위험뿐만 아니라, 스레드를 사용하기 때문에 생기는 추가 위험에도 노출된다.

잘 설계된 병렬 프로그램은 스레드를 사용해서 궁극적으로 성능을 향상시킬 수 있다.
하지만 스레드를 사용하면 실행 중에 어느 정도 부하가 생기는 것도 사실이다.
스레드가 많은 프로그램에서는 컨텍스트 스위칭이 더 빈번하고 그 때문에 상당한 부담이 생긴다.
즉 실행중인 컨텍스트를 저장하고 다시 읽어들여야 하며 메모리를 읽고 쓰는데 있어 지역성이 손실되고 스레드를 실행하기도 버거운 CPU 시간을 스케줄링하는 데 소모해야 한다.
또 스레드가 데이터를 공유할 때는 동기화 수단도 사용해야 한다.
이런 동기화는 컴파일러 최적화를 방해하고 메모리 캐시를 지우거나 무효화하기도 한다.
그 밖에 공유 메모리 버스에 동기화 관련 트래픽을 유발한다.
멀티스레드는 이런 모든 성능 측면에서 추가적인 손실을 유발한다.

# 1.4 스레드는 어디에나

프로그램을 작성할 때 스레드를 직접 생성하지 않더라도 프로그램이 사용하는 프레임웍에서 스레드를 생성할 수도 있다.
따라서 그런 스레드에서 호출되는 코드는 스레드에 대해 안전해야 한다.
따라서 스레드에 안전한 클래스를 개발할 때는 더 세심하게 주의하고 분석해야 하며 이런 면은 개발자 입장에서 볼 때 설계와 구현 어느 부분에서도 상당한 부담이 된다.

모든 자바 프로그램은 기본적으로 스레드를 사용한다.
JVM을 시작하면 main 메서드를 실행할 주 스레드 뿐 아니라 가비지 컬렉션이나 객체 종료와 같은 JVM 내부 작업을 담당할 스레드도 생성한다.
Swing 사용자 인터페이스 프레임웍은 사용자 인터페이스의 이벤트를 관리할 스레드를 생성하며 Timer는 대기 중인 작업을 실행할 스레드를 생성한다.
서블릿 같은 컴포넌트 프레임웍 역시 스레드를 관리하는 풀을 여러 개 생성하고 이 스레드를 사용해 컴포넌트의 메서드를 호출한다.

이와 같은 편리한 수단을 사용한다면 병렬성과 스레드 안정성에 대해 잘 알아야 한다.
거의 모든 자바 프로그램이 멀티스레드로 동작하는 프로그램이고 외부에서 프로그램 내부의 상태에 접근하는 과정을 적절히 조율하지 않아도 될 만큼의 기본적인 조율 기능을 프레임웍이 담당해 주지는 않는다.

프레임웍 때문에 프로그램이 병렬로 실행되는 경우가 생기면 병렬로 실행된다는 사실을 프레임웍 뿐만 아니라 프로그램에서도 인식하고 적절히 대응해야 한다.
프레임웍의 특성상 프로그램 컴포넌트의 기능을 호출해 결과를 받아오는 형태로 동작하는데 이런 과정에서 필수적으로 프로그램 내부의 상태를 사용하기 때문이다.
마찬가지로 프레임웍에 의해 호출되는 컴포넌트만 스레드에 안전해야 하는 것은 아니다.
해당 컴포넌트가 실행되는 과정에서 접근하는 코드 경로에 포함된 컴포넌트는 모두 마찬가지이다.
이처럼 스레드 안정성에는 전염성이 있다.

아래 설명한 편의 수단은 모두 프로그램이 관리하지 않는 외부 스레드에서 프로그램 코드를 호출한다.
이와 같은 외부의 편의 수단 자체가 먼저 스레드에 안전해야겠지만 그것으로 충분하지 않다.
스레드에 안전해야 한다는 필요성은 프로그램 전체로 퍼져 나간다.

### 타이머

Timer는 추후에 한 번 혹은 주기적으로 실행될 작업을 스케줄하기 위한 편의 수단이다.
Timer를 사용하면 TimerTask에 지정된 작업이 프로그램이 아닌 Timer가 관리하는 스레드에서 실행되기 때문에 순차적인 작업을 복잡하게 만들 수도 있다.
만약 기본 프로그램의 스레드가 사용하는 데이터에 TimerTask의 작업이 접근하면 TimerTask 뿐 아니라 해당 데이터에 접근하는 다른 모든 클래스도 스레드에 안전하게 만들어야 한다.
이런 경우에 가장 쉬운 방법은 TimerTask가 접근하는 객체 자체를 스레드에 안전하게 만드는 것이다.
즉 공유된 데이터 객체 내부에 스레드 안정성을 캡슐화하는 것이다.

### 서블릿과 JSP

서블릿 프레임웍은 웹 애플리케이션을 배치하고 원격 HTTP 클라이언트에서 오는 요청을 분배하기 위한 모든 기본 기능을 감당하도록 설계되어 있다.
서버에 도착하는 요청은 때론 순서대로 연결된 필터를 통해 결국 적절한 서블릿이나 JSP에 분배된다.
각 서블릿은 프로그램 논리를 구성하는 한 컴포넌트로 대규모 웹 사이트에서는 여러 클라이언트가 동시에 같은 서블릿에 요청을 전송할 수도 있다.
서블릿 명세에 따르면 서블릿은 여러 스레드에서 동시에 호출될 수 있게 적성돼야 한다.
다시 말해 서블릿은 스레드에 안전해야 한다.

설사 서블릿이 한 번에 한 스레드에서 호출된다고 확신할 수 있어도 웹 애플리케이션을 작성할 때는 스레드 안정성에 신경 써야 한다.
서블릿 프로그램 범위 겍체나 세션 범위 객체처럼 다른 서블릿과 공유하는 상태 정보에 접근할 때도 있다.
서블릿이 서블릿 간 혹은 요청들 간에 공유되는 객체에 접근할 때는 적절한 동기화 작업이 필요하다.
여러 요청 내에서 각기 다른 스레드로 동시에 접근하고 있을 수도 있기 때문이다.
서블릿 필터나 ServletContext와 HttpSession 같이 범위가 정해진 컨테이너에 저장된 객체뿐 아니라 서블릿과 JSP 자체도 스레드에 안전해야 한다.

### 원격 메서드 호출 (Remove method Invocation)

RMI는 다른 JVM에서 실행 중인 객체의 메소드를 호출할 수 있게 해 준다.
RMI로 원격 메소드를 호출하면 메소드 인자는 바이트 스트림으로 변환되고 네트워크를 통해 원격 JVM으로 전달된다.
원격 JVM에서는 원래대로 변환되어 원격 메소드에 인자로 전달된다.

RMI 코드가 원격 객체를 호출할 때 어느 스레드에서 호출될까?
개발자는 알 수 없지만 분명 개발자가 생성한 스레드는 아니다.
즉 RMI가 관리하는 스레드에서 호출된다.
그럼 RMI는 스레드를 몇 개나 생성할까?
동일한 원격 객체에 같은 메소드가 여러 RMI 스레드에서 동시에 호출될 수 있을까?

원격 객체는 스레드 안정성에 대한 두 가지 위험에 대비해야 한다.
먼저 다른 객체와 공유될 수 있는 상태에 접근할 때 적절히 조율해야 하지만 원격 객체 자체의 상태에 접근할 때도 마찬가지다.
서블릿처럼 RMI 객체도 동시에 여러 번 호출될 수 있게 작성해야 하며 스레드에 안전해야 한다.

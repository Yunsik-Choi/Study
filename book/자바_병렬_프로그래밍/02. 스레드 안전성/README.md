# 스레드 안정성

병렬 프로그램은 단순하게 스레드와 락만 신경써서 될 일은 아니다.
스레드에 안전한 코드를 작성하는 것은 근본적으로는 상태, 특히 공유되고 변경할 수 있는 상태에 대한 접근을 관리하는 것이다.

대략 말하면 객체의 상태는 인스턴스나 static 변수 같은 상태 변수에 저장된 객체의 데이터다.
객체의 상태에는 다른 객체의 필드에 대한 의존성이 포함될 수도 있다.
HashMap의 상태 가운데 일부는 HashMap 자체에 저장돼 있지만 상당량의 정보는 Map.Entry 객체에 저장돼 있다.
즉 외부로 노출된 HashMap 객체 뿐만 아니라 HashMap의 동작에 영향을 끼치는 내부의 Map.Entry 객체에도 영향을 끼친다.
객체의 상태에는 밖에서 보이는 동작에 영향을 끼치는 모든 데이터가 포함된다.

공유됐다는 것은 여러 스레드가 특정 변수에 접근할 수 있다는 뜻이고, 변경할 수 있다는 것은 해당 변수 값이 변경될 수 있다는 뜻이다.
스레드 안정성이 마치 코드를 보호하는 것처럼 이해하는 경우가 많지만 실제로는 데이터 제어 없이 동시 접근하는 걸 막으려는 의미임을 알아두자.

객체가 스레드에 안전해야 하느냐는 해당 객체에 여러 스레드가 접근할지의 여부에 달렸다.
즉 프로그램에서 객체가 어떻게 사용되는가의 문제지 그 객체가 뭘 하느냐와는 무관하다.
객체를 스레드에 안전하게 만들려면 동기화를 통해 변경할 수 있는 상태에 접근하는 과정을 조율해야 한다.
동기화가 제대로 되지 못하면 데이터가 손상되거나 기타 바람직하지 않은 여러 가지 결과가 생길 수 있다.

스레드가 하나 이상 상태 변수에 접근하고 그 중 하나라도 변수에 값을 쓰면 해당 변수에 접근할 때 관련된 모든 스레드가 동기화를 통해 조율해야 한다.
자바에서 동기화를 위한 기본 수단은 synchronized 키워드로서 배타적인 락을 통해 보호 기능을 제공한다.
하지만 volatile 변수, 명시적 락, 단일 연산 변수를 사용하는 경우에도 동기화 라는 용어를 사용한다.

만약 여러 스레드가 변경할 수 있는 하나의 상태 변수를 적절한 동기화 없이 접근하면 그 프로그램은 잘못된 것이다.

- 잘못된 프로그램을 고치는 세 가지 방법
    - 해당 상태 변수를 스레드 간에 공유하지 않는다.
    - 해당 상태 변수를 변경할 수 없도록 만든다.
    - 해당 상태 변수에 접근할 땐 언제나 동기화를 사용한다.

클래스를 설계하면서 애당초 동시 접근을 염두에 두지 않았다면 뒤늦게 고치려 할 때 매우 어려운 상황에 마주친다.
스레드 안정성을 확보하기 위해 나중에 클래스를 고치는 것보다는 애당초 스레드에 안전하게 설계하는 편이 훨씬 쉽다.

프로그램 규모가 커지면 특정 변수를 여러 스레드에서 접근하는지 파악하는 일조차 간단치 않을 수 있다.
객체 지향 프로그래밍 기법에서 사용하는 캡슐화나 데이터 은닉 같은 기법이 스레드에 안전한 클래스를 작성하는 데도 도움이 될 수 있다.
특정 변수에 접근하는 코드가 적을수록 적절히 동기화가 사용됐는지 확인하기 쉬우며 어떤 조건에서 특정 변수에 접근하는지도 판단하기 쉽다.
프로그램 상태를 잘 캡슐화할수록 프로그램을 스레드에 안전하게 만들기 쉽고 유지 보수에서도 해당 프로그램이 계속해서 스레드에 안전하도록 유지하기 쉽다.

때론 객체 지향 설계 기법이 실세계의 요구사항과 배치되는 경우도 있다.
이런 경우에는 바람직한 설계 원칙을 양보할 수밖에 없다.
때론 추상화와 캡슐화 기법이 성능과 배되기도 한다.
하지만 이런 경우 항상 코드를 올바르게 작성하는 일이 먼저이고 그 다음 성능을 개선해야 한다.

캡슐화 원칙을 깨뜨려도 프로그램을 스레드에 안전하게 만들 수 있다.
하지만 더 어려울 뿐 아니라 스레드 안전성이 깨지기도 쉬워지고 이는 개발 비용과 위험 부담 뿐 아니라 유지 보수 측면에서도 부담을 증가시킨다.

스레드 안전한 프로그램은 스레드 안전한 클래스로만 구성된 프로그램일까?
꼭 그런 건 아니다.
스레드 안전한 클래스로만 구성된 프로그램이 스레드 안전하지 않을 수 있다.
어느 경우든 클래스가 자신의 상태를 캡슐화해야만 스레드 안전한 클래스라는 개념이 의미가 있다.
스레드 안전성은 코드에 적용되는 용어일 수도 있지만 주로 상태에 대한 것이고 상태를 캡슐화하는 코드 전체에 적용될 수 있으며 적용되는 코드는 객체이거나 또는 프로그램 전체일 수도 있다.

## 2.1 스레드 안정성이란?

여러 스레드가 클래스에 접근할 때 실행 환경이 해당 스레드들의 실행을 어떻게 스케줄하든 어디에 끼워 넣든, 호출하는 쪽에서 추가적인 동기화나 다른 조율 없이도 정확하게 동작하면 해당 클래스는 스레드 안전하다고
말한다.

모든 단일 스레드 프로그램은 멀티스레드 프로그램의 한 종류라고 볼 수 있기 때문에 애당초 단일 스레드 환경에서도 제대로 동작하지 않으면 스레드 안전할 수 없다.
스레드에 안전한 클래스 인스턴스에 대해서는 순차적이든 동시든 어떤 작업들을 행해도 해당 인스턴스를 잘못된 상태로 만들 수 없다.
스레드에 안전한 클래스는 클라이언트 쪽에서 별도로 동기화할 필요가 없도록 동기화 기능도 캡슐화한다.

### 2.1.1 예제: 상태 없는 서블릿

``` java
@ThreadSafe
public class StatelessFactorizer implements Servlet {
  public void service(ServletRequest req, ServletResponse res) {
    BigInteger i = extractFromRequest(req);
    BigInteger[] factors = factor(i);
    encodeIntoResponse(resp, Factors);
  }
}
```

StatelessFactorizer는 대부분의 서블릿처럼 상태가 없다.
즉 선언한 변수가 없고 다른 클래스의 변수를 참조하지도 않는다.
특정 계산을 위한 일시적인 상태는 스레드의 스택에 저장되는 지역 변수에만 저장하고, 실행하는 해당 스레드에서만 접근할 수 있다.
따라서 StatelessFactorizer 에 접근하는 특정 스레드는 같은 StatelessFactorizer 에 접근하는 다른 스레드의 결과에 영향을 줄 수 없다.
두 스레드가 상태를 공유하지 않기 때문에 사실상 서로 다른 인스턴스에 접근하는 것과 같다.
상태 없는 객체에 접근하는 스레드가 어떤 일을 하든 다른 스레드가 수행하는 동작의 정확성에 영향을 끼칠 수 없기 때문에 상태 없는 객체는 항상 스레드 안전하다.

많은 서블릿을 상태 없이 구현할 수 있다는 점은 서블릿을 스레드 안전하게 만드는 부담을 줄여준다.
서블릿이 여러 요청 간에 뭔가를 기억할 필요가 있을 때에야 스레드 안전성이 문제가 된다.

## 2.2 단일 연산

StatelessFactorizer 에 처리한 요청의 수를 기록하는 '접속 카운터'를 추가해 보자.

``` java
@NotThreadSafe
public class UnsafeCountingFactorizer implements Servlet {
  private long count = 0;
  
  public long getCount() {
    return count;
  }
  
  public void service(ServletRequest req, ServletResponse res) {
    BigInteger i = extractFromRequest(req);
    BigInteger[] factors = factor(i);
    ++count;
    encodeIntoResponse(resp, Factors);
  }
}
```

UnsafeCountingFactorizer 는 스레드에 안전하지 않다.
값을 증가시키는 ++count는 한 줄짜리 간단한 코드인지라 단일 작업처럼 보이지만 실제로는 단일 연산이 아니다.
다시 말해 나눌 수 없는 최소 단위 작업으로 실행되는 게 아니라는 뜻이다.
해당 문장은 현재 값을 가져와서 거기에 1을 더하고 새 값을 저장하는 별도의 3개 작업을 순차적으로 실행하는 것을 한 줄의 코드로 간략히 표현한 것이다.

### 2.2.1 경쟁 조건

UnsafeCountingFactorizer에는 여러 종류의 경쟁 조건이 발생할 수 있기 때문에 결과를 신뢰할 수 없다.
경쟁 조건은 상대적인 시점이나 또는 JVM이 여러 스레드를 교차해서 실행하는 상황에 따라 계산의 정확성이 달라질 때 나타난다.
다시 말해 타이밍이 딱 맞을 때만 정답을 얻는 경우를 말한다.
가장 일반적인 경쟁 조건 형태는 잠재적으로 유효하지 않은 값을 참조해서 다음에 뭘 할지를 결정하는 점검 후 행동 check-then-act 형태의 구문이다.

원하는 결과를 얻을 수 있을지의 여부는 여러 가지 사건의 상대적인 시점에 따라 달라진다.
대부분 경쟁 조건은 이런 관찰 결과의 무효화로 특징 지어진다.
즉 잠재적으로 유효하지 않은 관찰 결과로 결정을 내리거나 계산을 하는 것이다.
이런 류의 경쟁 조건을 점검 후 행동이라고 한다.
어떤 사실을 확인하고 그 관찰에 기반해 행동을 한다.
하지만 해당 관찰은 관찰한 시각과 행동한 시각 사이에 더 이상 유효하지 않게 됐을 수도 있다.
이런 경우 문제가 발생한다.

### 2.2.2 예제: 늦은 초기화 시 경쟁 조건

점검 후 행동하는 흔한 프로그래밍 패턴으로 늦은 초기화가 있다.
늦은 초기화는 특정 객체가 실제 필요할 때까지 초기화를 미루고 동시에 단 한 번만 초기화되도록 하기 위한 것이다.

``` java
@NotThreadSafe
public class LazyInitRace {
  private ExpensiveObject instance = null;
  
  public ExpensiveObject getInstance() {
    if(instance == null) {
      instance = new ExpensiveObject();
    }
    return instance;
  }
}
```

LazyInitRace는 경쟁 조건 때문에 제대로 동작하지 않을 가능성이 있다.
스레드 A와 B가 동시에 getInstance를 수행한다고 하자.
instance라는 변수가 null이라는 사실을 본 다음 스레드 A는 ExpensiveObject의 인스턴스를 새로 생성한다.
스레드 B도 instance 변수가 null인지 살펴본다.
이때 null의 여부는 스케줄이 어떻게 변경될지 또는 스레드 A가 ExpensiveObject 인스턴스를 생성하고 instance 변수에 저장하기까지 얼마나 걸리는지 등의 예측하기 어려운 타이밍에 따라 달라진다.
원래 getInstance는 항상 같은 인스턴스를 리턴하도록 설계돼 있는데, 스레드 B가 살펴보는 그 시점에 instance가 null이면 getInstance를 호출한 두 스레드가 각각 서로 다른 인스턴스를 가져갈
수도 있다.

### 2.2.3 복합 동작

LazyInitRace와 UnsafeCountingFactorizer이 처리하는 일련의 작업은 외부 스레드에서 봤을 때 더 이상 나눠질 수 없는 단일 연산이어야 했다.
경쟁 조건을 피하려면 변수가 수정되는 동안 다른 스레드가 해당 변수를 사용하지 못하도록 막을 방법이 있어야 하며 이런 방법으로 보호해두면 특정 스레드에서 변수를 수정할 때 다른 스레드는 수정 도중이 아닌 수정
이전이나 이후에만 상태를 읽거나 변경을 가할 수 있다.

작업 A를 실행 중인 스레드 관점에서 다른 스레드가 작업 B를 실행할 때 작업 B가 모두 수행됐거나 또는 전혀 수행되지 않은 두가지 상태로만 파악된다면 작업 A의 눈으로 볼 때 작업 B는 단일 연산이다.
단일 연산 작업은 자신을 포함해 같은 상태를 다루는 모든 작업이 단일 연산인 작업을 지칭한다.

UnsafeSequence 내부에서 사용한 증가 연산이 단일 연산이었다면 경쟁 조건이 생길 수 없고 각 증가 연산은 의도했던 대로 카운터를 정확히 1만큼 증가시켰을 것이다.
스레드 안전성을 보호하기 위해 점검 후 행동과 읽고 수정하고 쓰기등의 작업은 항상 단일 연산이어야 한다.
점검 후 행동과 읽고 수정하고 쓰기 같은 일련의 동작을 복합 동작이라고 한다.
즉 스레드에 안전하기 위해서는 전체가 단일 연산으로 실행돼야 하는 일련의 동작을 지칭한다.

## 2.3 락

스레드 안정성의 정의에 따르면 여러 스레드에서 수행되는 작업의 타이밍이나 스케줄링에 따른 교차 실행과 관계 없이 불변조건이 유지돼야 스레드에 안전하다.

### 2.3.1 암묵적인 락

자바에는 단일 연산 특성을 보장하기 위해 synchronized 라는 구문으로 사용할 수 있는 락을 제공한다.
synchronized 구문은 락으로 사용될 객체의 참조 값과 해당 락으로 보호하려는 코드 블록으로 구성된다.
메소드 선언 부분에 synchronized 키워드를 지정하면 메소드 내부의 코드 전체를 포함하면서 메소드가 포함된 클래스의 인스턴스를 락으로 사용하는 synchronized 블록을 간략하게 표현한 것으로 볼 수
있다.

``` java
synchronized (lock) {
  // lock으로 보호된 공유 상태에 접근하거나 해당 상태를 수정한다.
}
```

모든 자바 객체는 락으로 사용할 수 있다.
이와 같이 자바에 내장된 락을 암묵적인 락 (intrinsic lock) 혹은 모니터 락 (monitor lock) 이라고 한다.
락은 스레드가 synchronized 블록에 들어가기 전에 자동으로 확보되며 정상적으로든 예외가 발생해서든 해당 블록을 벗어날 때 자동으로 해제된다.
해당 락으로 보호된 synchronized 블록이나 메소드에 들어가야만 암묵적인 락을 확보할 수 있다.

자바에서 암묵적인 락은 mutexes 또는 mutual exclusion lock 으로 동작한다.
즉 한 번에 한 스레드만 특정 락을 소유할 수 있다.
스레드 B가 가지고 있는 락을 스레드 A가 얻으려면 A는 B가 해당 락을 놓을 때까지 기다려야 한다.
만약 B가 락을 놓지 않으면 A는 영원히 기다릴 수밖에 없다.

특정 락으로 보호된 코드 블록은 한 번에 한 스레드만 실행할 수 있기 때문에 같은 락으로 보호되는 synchronized 는 서로 다른 블록 역시 서로 단일 연산으로 실행된다.
동시성 맥락에서 단일 연산 특성은 트랜잭션 프로그램에서 말하는 단일 연산 특성과 같은 의미다.
즉 일련의 문장이 하나의 나눌 수 없는 단위로 실행되는 것처럼 보인다는 것이다.
한 스레드가 synchronized 블록을 실행 중이라면 같은 락으로 보호되는 synchronized 블록에 다른 스레드가 들어와 있을 수 없다.

### 2.3.2 재진입성

스레드가 다른 스레드가 가진 락을 요청하면 해당 스레드는 대기 상태에 들어간다.
하지만 암묵적인 락은 재진입 가능하기 때문에 특정 스레드가 자기가 이미 획득한 락을 다시 확보할 수 있다.
재진입성은 확보 요청 단위가 아닌 스레드 단위로 락을 얻는다는 것을 의미한다.
재진입성을 구현하려면 각 락마다 확보 횟수와 확보한 스레드를 연결시켜 둔다.
확보 횟수가 0이면 락은 해제된 상태이다.
스레드가 해제된 락을 확보하면 JVM이 락에 대한 소유 스레드를 기록하고 확보 횟수를 1로 지정한다.
같은 스레드가 락을 다시 얻으면 횟수를 증가시키고 소유한 스레드가 synchronized 블록 밖으로 나가면 횟수를 감소시킨다.
이렇게 횟수가 0이되면 해당 락은 해제된다.
재진입성 떄문에 락의 동적을 쉽게 캡슐화할 수 있고 객체 지향 병렬 프로그램을 개발하기가 단순해졌다.

## 2.4 락으로 상태 보호하기

락은 자신이 보호하는 코드 경로에 여러 스레드가 순차적으로 접근하도록 하기 때문에 공유된 상태에 배타적으로 접근할 수 있도록 보장하는 규칙을 만들 때 유용하다.
이런 절차를 정확하게 따르면 항상 일관적인 상태를 유지할 수 있다.

경쟁 조건을 피하려면 복합 동작을 단일 연산으로 만들어야 한다.
줄곧 락을 확보한 상태로 복합 동작을 실행하면 해당 복합 동작을 단일 연산으로 보이게 할 수 있다.
하지만 단순히 복합 동작 부분을 synchronized 블록으로 감싸는 것으로는 부족하다.
특정 변수에 대한 접근을 조율하기 위해 동기화할 때는 해당 변수에 접근하는 모든 부분을 동기화해야 한다.
또한 변수에 대한 접근을 조율하기 위해 락을 사용할 땐 해당 변수에 접근하는 모든 곳에서 반드시 같은 락을 사용해야 한다.

흔한 실수 중 하나는 공유 변수에 값을 쓸 때만 동기화가 필요하다고 생각하기 쉽다는 점인데 이는 잘못된 생각이다.

여러 스레드에서 접근할 수 있고 변경 가능한 모든 변수를 대상으로 해당 변수에 접근할때는 항상 동일한 락을 먼저 확보한 상태여야 한다.
이 경우 해당 변수에는 확보된 락에 의해 보호된다고 말한다.

객체의 암묵적인 락과 그 객체의 상태 사이에 원천적인 관계는 없다.
많은 클래스에서 그렇게 사용해온 락에 대한 관례이긴 해도 특정 객체의 변수를 항상 그 객체의 암묵적인 락으로 보호해야 하는 건 아니다.
특정 객체의 락을 얻는다고 해도 다른 스레드가 해당 객체에 접근하는 걸 막을 순 없다.
락을 얻으면 단지 다른 스레드가 동일한 락을 얻지 못하게 할 수 있을 뿐이다.
모든 객체에 내장된 락이 있다는 점 때문에 매번 별도로 락 객체를 생성할 필요가 없어 단지 편리할 뿐이다.
공유 상태에 안전하게 접근할 수 있도록 락 규칙이나 동기화 정책을 만들고 프로그램 내에서 규칙과 정책을 일관성 있게 따르는 건 순전히 개발자에게 달렸다.

모든 변경할 수 있는 공유 변수는 정확하게 단 하나의 락으로 보호해야 한다.
유지 보수하는 사람이 알 수 있게 어느 락으로 보호하고 있는지 명확하게 표시해라.

락을 활용함에 있어 일반적인 사용 예는 먼저 모든 변경 가능한 변수를 객체 안에 캡슐화하고 해당 객체의 암묵적인 락을 사용해 캡슐화한 변수에 접근하는 모든 코드 경로를 동기화함으로써 여러 스레드가 동시에 접근하는
상태에서 내부 변수를 보호하는 방법이다.
이 때 객체의 상태를 나타내는 모든 변수는 객체의 암묵적인 락으로 보호된다.
하지만 이 패턴에는 전혀 특별한 부분이 없고 컴파일러나 JVM 어느 쪽에서도 이와 같은 락 패턴을 반드시 사용하도록 강요하지 않는다.
락에 대한 이 규칙은 새로운 메소드나 코드 경로를 추가하면서 실수로 동기화하는 걸 잊기만 해도 쉽게 무너질 수 있다.

모든 데이터를 락으로 보호해야 하는 건 아니고 변경 가능한 데이터를 여러 스레드에서 접근해 사용하는 경우에만 해당한다.

특정 변수가 락으로 보호되면 즉 해당 변수에 해당 락을 확보한 상태에서 접근하도록 하면 한 번에 한 스레드만 해당 변수에 접근할 수 있다는 점을 보장할 수 있다.
클래스에 여러 상태 변수에 대한 불변조건이 있으면 불변조건에 관련된 각 변수는 모두 같은 락으로 보호돼야 한다는 추가 요구사항이 붙는다.
이렇게 하면 관련된 모든 변수를 하나의 단일 연산 작업 내에서 접근하거나 갱신할 수 있다.

동기화가 경쟁 조건에 대한 해법이라면 왜 모든 메소드를 synchronized 로 선언하지 않았을까?
무차별적으로 synchronized 를 적용하면 동기화가 너무 과도하거나 심지어는 부족할 수 있다.

메소드를 동기화하면 각 메소드의 작업을 단일 연산으로 만들지만 여러 메소드가 하나의 복합 동작으로 묶일 땐 락을 사용해 추가로 동기화해야 한다.
모든 메소드를 동기화하면 활동성이나 성능에 문제가 생길 수도 있다.

## 2.5 활동성과 성능

서블릿 프레임워크의 메소드에 synchronized 키워드를 지정하면 메소드는 한 번에 한 스레드만 실행할 수 있다.
이는 동시에 여러 요청을 처리할 수 있게 설계된 서블릿 프레임웍의 의도와 배치되고 요청이 많아졌을 경우 성능 저하가 발생한다.
심지어 이미 캐시돼 있어서 빨리 처리될 수 있는 요청도 오래 걸리는 이전 작업들 때문에 덩달아 처리가 늦어질 수 있다.

이런 방법으로 동작하는 웹 애플리케이션은 병렬 처리 능력이 떨어진다고 말한다.
즉 처리할 수 있는 동시 요청의 개수가 자원의 많고 적음이 아닌 애플리케이션 자체의 구조 때문에 제약된다.
다행히 synchronized 블록의 범위를 줄이면 스레드 안정성을 유지하면서 쉽게 동시성을 향상시킬 수 있다.
이 때 synchronized 블록의 범위를 너무 작게 줄이지 않도록 조심해야 한다.
다시 말해 단일 연산으로 처리해야 하는 작업을 여러 개의 synchronized 블록으로 나누진 말아야 한다.
하지만 다른 스레드가 공유 상태에 접근할 수 있도록 오래 걸리는 작업을 synchronized 블록에서 최대한 뽑아 낼 필요는 있다.

CacheFactorizer 는 전체 메소드를 동기화하는 대신 두 개의 짧은 코드 블록을 synchronized 키워드로 보호했다.
하나는 캐시된 결과를 갖고 있는지 검사하는 일종의 확인 후 동작 부분이고 또 하나는 캐시된 입력 값과 결과를 새로운 값으로 변경하는 부분이다.
덤으로 접속 카운터를 다시 넣고 "캐시가 사용된 횟수"를 세는 카운터도 추가했다.
두 개의 카운터 값은 첫 번째 synchronized 블록에서 변경한다.
두 카운터 역시 변경할 수 있는 공유 상태에 속하기 때문에 접근할땐 항상 동기화 구문을 사용해야 한다.
synchronized 블록 밖에 코드는 다른 스레드와 공유되지 않는 지역 변수만 사용하기 때문에 동기화가 필요 없다.

``` java
@ThreadSafe
public class CachedFactorizer implements Servlet {
    @GuardedBy("this")
    private BigInteger lastNumber;
    @GuardedBy("this")
    private BigInteger[] lastFactors;
    @GuardedBy("this")
    private long hits;
    @GuardedBy("this")
    private long cacheHits;

    public synchronized long getHits() {
        return hits;
    }

    public synchronized double getCacheHitRatio() {
        return (double) cacheHits / (double) hits;
    }
    
    public void service(ServletRequest req, ServleResponse resp) {
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = null;
        synchronized (this) {
            ++hits;
            if(i.equals(lastNumber)) {
                ++cacheHits;
                factors = lastFactors.clone();
            }
        }
        if(factors == null) {
            factors = factor(i);
            synchronized (this) {
                lastNumber = i;
                lastFactors = factors.clone();
            }
        }
        encodeIntoResponse(resp, factors);
    }
}
```

CachedFactorizer 는 이제 접속 카운터로 AtomicLong 대신 예전 방식대로 long 필드를 쓴다.
여기서 AtomicLong 클래스를 써도 괜찮지만 CachedFactorizer 때에 비해 별다른 장점이 없다.
단일 연산 변수는 변수에 일반적인 변수에 단일 연산 작업을 수행할 때 유용하지만 여기에서는 이미 synchronized 블록을 사용해 동기화하고 있다.
따라서 서로 다른 두 가지 동기화 수단을 사용해 봐야 혼동을 줄 뿐 성능이나 안정성 측면의 이점이 없다.

synchronized 블록의 크기를 적정하게 유지하려면 안정성, 단숭성, 성능 등이 서로 상충하는 설계 원칙 사이에 적절한 타협이 필요할 수 있다.
때론 단순성과 성능이 서로 상충되는데 일반적으로는 CachedFactorizer 와 같이 적절한 타협점을 찾을 수 있다.

락을 사용할 땐 블록 안의 코드가 무엇을 하는지 수행하는 데 얼마나 걸릴지를 파악해야 한다.
계산량이 많은 작업을 하거나 잠재적으로 대기 상태에 들어 갈 수 있는 작업을 하느라 락을 오래 잡고 있으면 활동성이나 성능 문제를 야기할 수 있다.

복잡하고 오래 걸리는 계산 작업, 네트워크 작업, 사용자 입출력 작업과 같이 빨리 끝나지 않을 수 있는 작업을 하는 부분에서는 가능한 락을 잡지 말아라.

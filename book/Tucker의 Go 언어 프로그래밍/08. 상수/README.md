# 상수 선언
상수는 변하지 않는 값을 말합니다.
상수는 정수, 실수 문자열 등 기본 타입값들만 상수로 선언될 수 있습니다.
구조체, 배열 등 기본 타입이 아닌 타입에는 상수를 사용할 수 없습니다.

Go 언어에서 사용될 수 있는 타입
- 불리언
- 정수
- 복소수
- 룬
- 실수
- 문자열

``` go
package main

import "fmt"

func main() {
    const PI float64 = 3.1415926553589793238
}
```

## iota

iota 키워드는 0부터 시작해 1씩 증가합니다.
iota는 소괄호를 벗어나면 다시 초기화됩니다.

``` go
const (
    Red int = iota // 0
    Blue int = iota // 1
    Green int = iota // 2
)
```

만약 첫 번째 값과 똑같은 규칙이 계속 적용된다면 iota를 생략할 수 있습니다.

``` go
const (
    C1 unit = iota + 1
    C2
    C3    
)
```

C2는 타입과 iota를 생략했기 때문에 C1과 마찬가지로 C2 unit = iota + 1로 적용됩니다.
iota가 1로 증가해서 C2값은 2가 됩니다.
C3 값은 iota가 2로 증가해서 3이 됩니다.

## 타입이 없는 상수

상수 선언 시 타입을 명시하지 않을 수 있습니다.
그러면 타입 없는 상수가 됩니다.
타입 없는 상숫값은 타입이 정해지지 않은 상태로 사용됩니다.

``` go
package main

import "fmt"

const PI = 3.14
const FloatPI float64 = 3.14

func main() {
    var a int = PI * 100 // 오류가 발생하지 않습니다.
    var b int = FloatPI * 100 // 타입 오류 발생

    fmt.Println(a)
    fmt.Println(b)
}
```

타입 없는 상수는 변수에 복사될 때 타입이 정해지기 때문에 여러 타입에 사용되는 상숫값을 사용할 때 편리합니다.

## 상수와 리터럴

``` go
var str string = "Hello World"
var i int = 0
i = 30
```

위 코드에서 "Hello World", 0, 30과 같이 고정된 값 자체로 쓰인 문구가 리터럴입니다.
Go 언어에서 상수는 리터럴과 같이 취급합니다.
컴파일될 때 상수는 리터럴로 변환되어 실행 파일에 쓰입니다.

상수 표현식 역시 컴파일 타임에 실제 결괏값 리터럴로 변환하기 때문에 상수 표현식 계산에 CPU 자원을 사용하지 않습니다.

``` go
const PI = 3.14
var a int = PI * 100
```

위 구문은 컴파일 타임에 아래와 같이 변환됩니다.

``` go
var a int = 314
```

상수의 메모리 주솟값에 접근할 수 없는 이유 역시 컴파일 타임에 리터럴로 전환되어 실행 파일에 값 형태로 쓰이기 때문입니다.
그래서 동적 할당 메모리 영역을 사용하지 않습니다.
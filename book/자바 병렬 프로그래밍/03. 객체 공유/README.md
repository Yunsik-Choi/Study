# 객체 공유

병렬 프로그램 작성은 상태가 바뀔 수 있는 내용을 프로그램 내부의 여러 부분에서 어떻게 잘 공유해 사용하도록 관리할 것인지에 대한 문제다.
이번에는 여러 개의 스레드에서 특정 객체를 동시에 사용하려 할 때 섞이지 않고 안전하게 동작하도록 객체를 공유하고 공개하는 방법을 살펴본다.

synchronized 키워드를 사용하면 동기화시킨 블록이 단일 연산인 것처럼 동작하게 할 수 있다.
하지만 특정 블록을 단일 연산인 것처럼 동작시키거나 크리티컬 섹션을 구성할 때 반드시 synchronized 키워드를 사용해야 하는 것은 아니다.
소스코드의 특정 블록을 동기화시키고자 할 때는 항상 메모리 가시성 문제가 발생하는데 큰 문제일 수도 있고 아닐 수도 있다.
특정 변수의 값을 사용하고 있을 때 다른 스레드가 해당 변수의 값을 사용하지 못하도록 막아야 할 뿐만 아니라 값을 사용한 다음 동기화 블록을 빠져나가고 나면 다른 스레드가 변경된 값을 즉시 사용할 수 있게 해야
한다.
적절한 방법으로 동기화시키지 않으면 다른 스레드에서 값을 제대로 사용하지 못하는 경우도 생길 수 있다.
따라서 항상 특정 객체를 명시적으로 동기화시키거나 객체 내부에 적절한 동기화 기능을 내장시켜야 한다.

## 3.1 가시성

만약 단일 스레드만 사용하는 환경이라면 특정 변수에 값을 지정하고 다음번에 해당 변수의 값을 다시 읽어보면 이전에 저장해뒀던 바로 그 값을 가져올 수 있다.
만약 특정 변수에 값을 저장하거나 읽어내는 코드가 여러 스레드에서 실행된다면 반드시 그렇지 않을 수도 있다.
특정 변수의 값을 가져갈 때 다른 스레드가 작성한 값을 가져갈 수 있다는 보장도 없고 심지어 값을 읽지 못할 수도 있다.
메모리상의 공유된 변수를 여러 스레드에서 서로 사용할 수 있게 하려면 반드시 동기화 기능을 구현해야 한다.

``` java
public class Main {
    private static boolean ready;
    private static int number;

    private static class ReaderThread extends Thread {
        public void run() {
            while (!ready) {
                Thread.yield();
            }
            System.out.println(number);
        }
    }

    public static void main(String[] args) {
        new ReaderThread().start();
        number = 42;
        ready = true;
    }
}
```

위 코드는 일반적으로 읽기 스레드가 42 라는 값을 출력하리라고 생각할 수 있겠지만 0 이라는 값을 출력할 수도 있고 영원히 값을 출력하지 못할 수도 있다.
메인 스레드에서 number 변수와 ready 변수에 지정한 값을 읽기 스레드에서 사용할 수 없는 상황인데 두 개 스레드에서 변수를 공유해 사용함에도 불구하고 적절한 동기화 기법을 사용하지 않기 때문이다.
ready 변수의 값을 읽기 스레드에서 영영 읽지 못할 수도 있기 때문에 무한 반복에 빠질 수 있다.
더 이상하게는 읽기 스레드가 메인 스레드에서 number 변수에 지정한 값보다 ready 변수의 값을 먼저 읽어가는 상황도 가능하다.
흔히 재배치 라고 하는 현상이다.
재배치 현상은 특정 메소드의 소스코드가 100% 코딩된 순서로 동작한다는 점을 보장할 수 없다는 점에 기인하는 문제이며 단일 스레드로 동작할 떄는 차이점을 전혀 알아챌 수 없지만 여러 스레드가 동시에 동작하는 경우
나타날 수 있다.
메인 스레드는 number 변수에 값을 먼저 저장하고 ready 변수에 값이 먼저 쓰여진 이후에 number 변수에 값이 저장되는 것처럼 순서가 바뀌어 보일 수도 있고 심지어는 아예 변경된 값을 읽기 못할 수도
있다.

동기화 기능을 지정하지 않으면 컴파일러나 프로세서, JVM 등이 프로그램 코드가 실행되는 순서를 임의로 바꿔 실행하는 이상한 경우가 발생하기도 한다.
다시 말하자면 동기화 되지 않은 상황에서 메모리상의 변수를 대상으로 작성해둔 코드가 반드시 이런 순서로 동작할 것이다라고 단정지을 수 없다.

### 3.1.1 스테일 데이터

스테일 데이터란 변수를 사용하는 모든 경우에 동기화를 시켜두지 않으면 해당 변수에 대한 최신 값이 아닌 다른 값을 사용하게 되는 경우를 말한다.
더 큰 문제는 특정 스레드가 어떤 변수를 사용할 때 항상 스테일 데이터를 사용하게 될 때도 있고, 정상적으로 동작하는 경우도 있다는 점이다.

### 3.1.2 단일하지 않은 64비트 연산

동기화되지 않은 상태에서 특정 스레드가 변수의 값을 읽으려 한다면 스테일 상태의 값을 읽어갈 가능성이 있긴 하지만 그래도 전혀 엉뚱한 값을 가져가는 것이 아니라 바로 이전에 다른 스레드에서 설정한 값을 가져가게
된다.

하지만 64비트를 사용하는 숫자형에 volatile 키워드를 사용하지 않은 경우에는 난데없는 값마저 생길 가능성이 있다.
자바 메모리 모델은 메모리에서 값을 가져오고 저장하는 연산이 단일해야 한다고 정의하고 있지만 volatile로 지정되지 않은 long이나 double 형의 64비트 값에 대해서는 메모리에 쓰거나 읽을 때 두 번의
32비트 연산을 사용할 수 있도록 허용하고 있다.
따라서 volatile을 지정하지 않은 long 변수의 값을 쓰는 기능과 읽는 기능이 서로 다른 스레드에서 동작한다면, 이전의 최신 값에서 각각 32비트를 읽어올 가능성이 생긴다.
따라서 스테일 문제를 신경 쓰지 않는다 해도 volatile로 지정하지도 않고 락을 사용해 동기화하지도 않은 상태로 long이나 double 값을 동시에 여러 스레드에서 사용할 수 있다면 항상 이상한 문제를 만날
가능성이 있다.

### 3.1.3 락과 가시성

만약 synchronized 등으로 동기화하지 않으면 변수의 값을 제대로 읽어간다고 절대로 보장할 수 없다.

값을 변경할 수 있는 변수를 여러 개의 스레드에서 동시에 사용한다면 바로 이전 스레드에서 사용했던 변수의 값을 오류 없이 정상적으로 다음 스레드가 사용할 수 있게 하기 위해 동일한 락을 사용하는
synchronized 블록으로 막아줄 필요가 있다.
여러 스레드에서 사용하는 변수를 적당한 락으로 막아주지 않는다면 스테일 상태에 쉽게 빠질 수 있다.

락은 상호 배제 뿐만 아니라 정상적인 메모리 가시성을 확하기 위해서도 사용한다.
변경 가능하면서 여러 스레드가 공유해 사용하는 변수를 각 스레드에 각자 최신의 정상적인 값으로 활용하려면 동일한 락을 사용해 모두 동기화시켜야 한다.

### volatile 변수

자바 언어에서는 volatile 변수로 약간 다른 형태의 좀더 약한 동기화 기능을 제공하는데, 다시 말해 volatile로 선언된 변수의 값을 바꿨을 때 다른 스레드에서 항상 최신 값을 읽어갈 수 있도록 해준다.
특정 변수를 선언할 때 volatile 키워드를 지정하면 컴파일러와 런타임 모두 '이 변수는 공유해 사용하고 따라서 실행 순서를 재배치 해서는 안된다' 라고 이해한다.
volatile로 지정된 변수는 프로세서의 레지스터에 캐시되지도 않고 프로세서 외부의 캐시에도 들어가지 않기 때문에 volatile 변수의 값을 읽으면 항상 다른 스레드가 보관해둔 최신의 값을 읽어 갈 수 있다.

volatile로 지정한 변수는 아무런 락이나 동기화 기능이 동작하지 않기 때문에 synchronized를 사용한 동기화보다는 아무래도 강도가 약할 수 밖에 없다.

실제로 volatile 변수가 갖는 가시성 효과는 volatile로 지정된 변수 자체의 값에 대한 범위보다 약간 확장되어 있다.
스레드 A가 volatile 변수에 값을 써넣고 스레드 B가 해당 변수의 값을 읽어 사용한다고 할 때, 스레드 B가 volatile 변수의 값을 읽고 나면 스레드 A가 변수에 값을 쓰기 전에 볼 수 있었던 모든
변수의 값을 스레드 B도 모두 볼 수 있다는 점이다.
따라서 메모리 가시성 입장에서 본다면 volatile 변수를 사용하는 것과 synchronized 키워드로 특정 코드를 묶는 게 비슷한 효과를 가져오고 volatile 값을 읽고 나면 synchronized 블록에
진입하는 것과 비슷한 상태에 해당한다.
어쨌거나 메모리 가시성 효과가 있긴 하지만 그렇다고 volatile 변수에 의존하지 않는 게 좋다.
volatile 변수만 사용해 메모리 가시성을 확보하도록 작성한 코드는 synchronized로 직접 동기화한 코드보다 훨씬 읽기가 어렵고 따라서 오류가 발생할 가능성도 높다.

동기화하고자 하는 부분을 명확하게 볼 수 있고 구현하기가 훨씬 간단한 경우에만 volatile 변수를 활용하자.
반대로 작은 부분이라도 가시성을 추론해봐야 하는 경우에는 volatile 변수를 사용하지 않는 것이 좋다.
volatile 변수를 사용하는 적절한 경우는 일반적으로 변수에 보관된 클래스 상태에 대한 가시성을 확보하거나 중요한 이벤트가 발생했다는 등의 정보를 정확하게 전달하고자 하는 경우 등이 해당된다.

락을 사용하면 가시성과 연산의 단일성 모두 보장받을 수 있다.
하지만 volatile 변수는 연산의 단일성은 보장하지 못하고 가시성만 보장한다.

volatile 변수를 사용하는 경우

- 변수에 값을 저장하는 작업이 해당 변수의 현재 값과 관련이 없거나 해당 변수의 값을 변경하는 스레드가 하나만 존재
- 해당 변수가 객체의 불변 조건을 이루는 다른 변수와 달리 불변 조건에 관련되어 있지 않다.
- 해당 변수를 사용하는 동안에는 어떤 경우라도 락을 걸어 둘 필요가 없는 경우

## 3.2 공개와 유출

특정 객체를 현재 코드의 스코프 범위 밖에서 사용할 수 있도록 만들면 공개되었다고 한다.
예를 들어 스코프 밖의 코드에서 볼 수 있는 변수에 스코프 내부의 객체에 대한 참조를 저장하거나 private이 아닌 메소드에서 호출한 메소드가 내부에서 생성한 객체를 리턴하거나, 다른 클래스의 메소드로 객체를
넘겨주는 경우 등이 해당된다.
일반적으로는 특정 객체는 물론이거니와 해당 객체 내부의 구조가 공개되지 않도록 작업하는 경우가 많다.
아니면 특정 객체를 공개해서 여러 부분에서 공유해 사용할 수 있도록 만들기도 하는데 이런 경우에는 반드시 해당 객체를 동기화시켜야 한다.
만약 클래스 내부 상태 변수를 외부에 공개해야 한다면 객체 캡슐화 작업이 물거품이 되가나 내부 데이터 안정성을 해칠 수 있다.
따라서 객체가 안정적이지 않은 상태에서 공개하면 스레드 안정성에 문제가 생길 수 있다.
이처럼 의도적으로 공개시키지 않았지만 외부에서 사용할 수 있게 공개된 경우를 유출 상태라고 한다.

객체를 공개하면 private이 아닌 모든 변수 속성에 연결되어 있는 모든 객체가 함께 공개된다.
객체를 공개했을 때 그 객체 내부의 private이 아닌 변수나 메소드를 통해 불러올 수 있는 모든 객체는 함께 공개된다.

다른 스레드에서 공개된 객체를 사용해 실제로 어떤 작업을 하지 않아도 항상 누군가 공개된 객체를 잘못 사용할 가능성에 노출되는 셈이다.
어떤 객체건 일단 유출되고 나면 다른 스레드가 유출된 클래스를 의도적이건 의도적이지 않던 간에 반드시 잘못 사용할 수 있다고 가정해야 한다.
객체가 유출되는 상황에서 어려운 문제점을 겪을 수도 있기 때문에 객체 내부는 캡슐화 해야 한다는 것이다.
객체 내부에서 사용하는 값이 적절하게 캡슐화되어 있다면 프로그램이 정상적으로 동작할 것이라고 쉽게 예측할 수 있고 예상치 못한 상황에서 원래 설계했던 동작을 벗어나지 않도록 제한할 수 있다.

객체나 객체 내부의 상태 값이 외부에 공개되는 또 다른 예는 내부 클래스의 인스턴스를 외부에 공개하는 경우이다.
내부 클래스는 항상 부모 클래스에 대한 참조를 갖고 있기 때문에 내부 클래스를 공개하면 부모 클래스도 함께 공개된다.

### 3.2.1 생성자 안정성

일반적으로 생성자가 완전히 종료하고 난 이후가 되어야 객체의 상태가 개발자가 예상한 상태로 초기화되기 때문에 생성 메소드가 실행되는 도중에 해당 객체를 외부에 공개한다면 정상적이지 않은 상태의 객체를 외부에서 불러
사용할 가능성이 있다.
이런 일은 공개하는 코드가 생성자 가운데 부분에 있을 뿐만 아니라 생성자의 가장 마지막 부분에 공개하는 코드가 있다 해도 충분히 가능한 일이다.
생성자 실행 도중에 this 변수가 외부에 공개된다면 이론적으로 해당 객체는 정상적으로 생성되지 않았다고 말할 수 있다.
생성자를 실행하는 도중에는 this 변수가 외부에 유출되지 않게 해야 한다.

생성자에서 this 변수를 유출시키는 가장 흔한 오류는 생성자에서 스레드를 새로 만들어 시작시키는 일이다.
생성자에서 또 다른 스레드를 만들어 내면 대부분의 경우에는 생성자의 클래스와 새로운 스레드가 this 변수를 직접 공유하거나 자동으로 공유되기도 한다.
예를 들어 생성자에서 만든 스레드의 클래스가 원래 클래스의 내부 클래스라면 자동으로 원래 클래스의 this 변수를 공유하는 상태가 된다.
그러면 새로 만들어져 실행된 스레드에서 원래 클래스의 생성자가 끝나기도 전에 원래 클레스에 정의되어 있는 여러 가지 변수를 직접 사용할 수 있게 된다.
필요한 기능이 있다면 생성자에서 스레드를 생성하는 건 별 문제가 없는 일이지만 스레드 생성과 동시에 시작시키는 건 문제의 소지가 많은 일이다.
스레드를 생성하면서 바로 시작시키기보다는 스레드를 시작시키는 기능을 start나 initialize 등의 메소드로 만들어 사용하는 편이 좋다.
생성 메소드에서 오버라이드 가능한 다른 메소드를 호출하는 경우가 있다면 this 참조가 외부에 유출될 가능성이 있다.

## 3.3 스레드 한정

변경 가능한 객체를 공유해 사용하는 경우에는 항상 동기화시켜야 한다.
만약 동기화를 시키지 않아야 한다면 기본적으로는 객체를 공유해 사용하지 않을 수밖에 없다.
특정 객체를 단일 스레드에서만 활용한다고 확신할 수 있다면 해당 객체는 따로 동기화할 필요가 없다.
이처럼 객체를 사용하는 스레드를 한정하는 방법으로 스레드 안정성을 확보할 수 있다.
객체 인스턴스를 스레드에 한정시켜두면 해당하는 객체가 아니라 해도 자동으로 스레드 안정성을 확보하게 된다.

스레드 한정 기법을 사용하는 사례는 바로 JDBC의 Connection 객체를 풀링해 사용하는 경우이다.
JDBC 표준에 따르면 JDBC의 Connection 객체가 반드시 스레드 안정성을 확보하고 있어야 하는건 아니다.
일반적인 서버 애플리케이션을 보면 풀에서 DB 연결을 확보하고 확보한 DB 연결로 요청 하나를 처리한 다음 사용한 연결을 다시 반환하는 과정을 거친다.
서블릿 요청이나 EJB 호출 등의 요청은 대부분 단일 스레드에서 동기적으로 처리하며 DB 풀은 한쪽에서 DB 연결을 사용하는 동안에는 해당 연결을 다른 스레드가 사용하지 못하게 막기 때문에 공유하는
Connection 객체를 풀로 관리하면 특정 Connection을 한 번에 하나 이상의 스레드가 사용하지 못하도록 한정할 수 있다.

언어적인 차원에서 특정 변수를 대상으로 락을 걸 수 있는 기능을 제공하지 않은 것처럼 임의의 객체를 특정 스레드에 한정시키는 기능도 제공하지 않는다.
스레드 한정 기법은 프로그램을 처음 설계하는 과정부터 함께 다뤄야 하며 프로그램을 구현하는 과정 내내 한정 기법을 계속해서 적용해야 한다.
하지만 기본 라이브러리만으로 스레드 한정 기법을 적용할 수도 있지만 이런 방법을 사용했다 하더라도 개발자는 스레드에 한정된 객체가 외부로 유출되지 않도록 항상 신경 써야 한다.

### 3.3.1 스레드 한정 - 주먹구구식

스레드 한정 기법을 구현 단계에서 완전히 '알아서 잘' 처리해야 할 경우가 있을 수 있는데 이런 경우에는 임시방편으로 스레드 한정 기법을 적용할 수 있다.
물론 로컬 변수를 사용하면서 가시성을 제어하는 등의 언어적인 방법으로는 객체를 특정 스레드에 한정할 수 없기 때문에 임시방편을 사용할 수밖에 없는데, 그러다 보니 오류가 발생할 가능성이 높다.

스레드 한정 기법을 사용할 것인지를 결정하는 일은 특정 시스템을 단일 스레드로 동작하도록 만들 것이냐에 따라 달려 있다.
특정 모듈의 기능을 단일 스레드로 동작하도록 구현한다면 언어적인 지원 없이 직접 구현한 스레드 한정 기법에서 나타날 수 있는 오류의 가능성을 최소화할 수 있다.

특정 스레드에 한정하려는 객체가 volatile로 선언되어 있다면 약간 특별한 경우로 생각할 수 있다.
이전에 살펴본 것처럼 읽기와 쓰기가 모두 가능한 volatile 변수를 공유해 사용할 때에는 특정 단일 스레드에서만 쓰기 작업을 하도록 구현해야 안전하다.
이런 경우 경쟁 조건을 막기 위해 변경 작업은 특정 스레드 한 곳에서만 할 수 있도록 제한해야 하고 읽기 작업이 가능한 모든 스레드는 volatile 변수의 특성상 가장 최근에 업데이트된 값을 정확하게 읽어갈 수
있다.

임시방편젹인 스레드 한정 기법은 안정성을 완벽하게 보장할 수 있는 방법은 아니기 때문에 꼭 필요한 곳에만 제한적으로 사용하는게 좋다.
그리고 가능하다면 좀더 안전한 스레드 한정 기법을 사용하자.

### 3.3.2 스택 한정

스택 한정 기법은 특정 객체를 로컬 변수를 통해서만 사용할 수 있는 특별한 경우의 스레드 한정 기법이라고 할 수 있다.
변수를 클래스 내부에 숨겨두면 변경 상태를 관리하기가 쉬운데 또한 클래스 내부에 숨겨둔 변수는 특정 스레드에 쉽게 한정시킬 수 도 있다.
로컬 변수는 모두 암묵적으로 현재 실행 중인 스레드에 한정되어 있다고 볼 수 있다.
즉 로컬 변수는 현재 실행 중인 스레드 내부의 스택에만 존재하기 때문이며, 스레드 내부의 스택은 외부 스레드에서 물론 볼 수 없다.
스택 한정 기법은 사용하기도 간편하고 앞에서 살펴봤던 임시방편적인 스레드 한정 기법보다 더 안전하다.

기본 변수형을 사용하는 로컬 변수는 일부러 하려고 해도 스택 한정 상태를 깰 수 없다.
기본 변수형은 객체와 같이 참조되는 값이 아니기 때문인데 이처럼 기본 변수형을 사용하는 로컬 변수는 언어적으로 스택 한정 상태가 보장된다.
객체형 변수가 스택 한정 상태를 유지할 수 있게 하려면 해당 객체에 대한 참조가 외부로 유출되지 않도록 개발자가 직접 주의를 기울여야 한다.

스레드에 안전하지 않은 객체라 해도 특정 스레드 내부에서만 사용한다면 동기화 문제가 없기 때문에 안전하다.
하지만 해당 객체를 현재 스레드에 한정해야 한다는 요구사항과 해당 객체가 스레드에 안전하지 않다는 점은 대부분 코드를 작성했던 개발자만 인식할 뿐 후임 개발자는 전혀 전달받지 못하는 경우가 많다.
따라서 이런 점을 명확하게 정리해 누구든지 알아볼 수 있도록 표시해 두는 것이 좋다.

### 3.3.3 ThreadLocal

스레드 내부의 값과 값을 갖고 있는 객체를 연결해 스레드 한정 기법을 적용할 수 있도록 도와주는 좀더 형식적인 방법으로 ThreadLocal이 있다.
ThreadLocal 클래스에는 get과 set 메소드가 있느데 호출하는 스레드마다 다른 값을 사용할 수 있도록 관리해준다.
다시 말해 ThreadLocal 클래스의 get 메소드를 호출하면 현재 실행 중인 스레드에서 최근에 set 메소드를 호출해 저장했던 값을 가져올 수 있다.

스레드 로컬 변수는 변경 가능한 싱글턴이나 전역 변수 등을 기반으로 설계되어 있는 구조에서 변수가 임의로 공유되는 상황을 막기 위해 사용하는 경우가 많다.
예를 들어 단일 스레드로 동작하는 애플리케이션에서 데이터베이스에 접속할 때 매번 Connection 인스턴스를 만들어 내는 부담을 줄이고자 프로그램 시작 시점에 Connection 인스턴스를 하나 만들어 전역 변수에
넣어두고 계속해서 사용하는 방법을 사용하기도 한다.
하지만 JDBC 연결은 스레드에 안전하지 않기 때문에 멀티 스레드 애플리케이션에서 적절한 동기화 없이 연결 객체를 전역 변수로 만들어 사용하면 애플리케이션 역시 스레드에 안전하지 않다.
하지만 JDBC 연결을 보관할때 ThreadLocal을 사용하면 스레드는 저마다 각자의, 연결 객체를 갖게 된다.
이런 방법은 굉장히 자주 호출하는 메소드에서 임시 버퍼와 같은 객체를 만들어 사용해야 하는데 임시로 사용할 객체를 매번 새로 생성하는 대신 이미 만들어진 객체를 재활용하고자 할 때 많이 사용한다.

특정 스레드가 ThreadLocal.get 메소드를 처음 호출한다면 initialValue 메소드에서 값을 만들어 해당 스레드에게 초기 값으로 넘겨준다.
개념적으로 본다면 ThreadLocal<T> 클래스는 Map<Thread,T> 라는 자료 구조로 구성되어 있고 Map<Thread,T> 에 스레드별 값을 보관한다고 생각할 수 있겠다.
물론 ThreadLocal이 Map<Thread,T>를 사용해 구현되어 있다는 말은 아니다.
스레드별 값은 실제로 Thread 객체 자체에 저장되어 있으며 스레드가 종료되면 스레드별 값으로 할당되어있던 부분도 가비지 컬렉터가 처리한다.

만약 원래 단일 스레드에서 동작하던 기능을 멀티스레드 환경으로 구성해야 할때 그 의미에 따라 다르지만 공유된 전역 변수를 ThreadLocal을 활용하도록 변경하면 스레드 안정성을 보장할 수 있다.
단일 스레드 애플리케이션에서 프로그램 전체를 대상으로 사용하던 캐시를 멀티스레드 애플리케이션에서는 여러 개의 스레드별 캐시로 나눠 사용하는 편이 더 효과적일 것이다.

ThreadLocal 클래스는 애플리케이션 프레임웍을 구현할 때 상당히 많이 사용되는 편이다.
예를 들어 J2EE 컨테이너는 EJB를 사용하는 동안 해당 스레드와 트랜잭션 컨텍스트를 연결해서 관리한다.
이처럼 스레드 단위로 트랜잭션 컨텍스트를 관리하고자 할때는 static으로 선언된 ThreadLocal 변수에 트랜잭션 컨텍스트를 넣어두면 편리하다.
만약 프레임웍에서 현재 진행 중인 트랜잭션이 어느 것인지 확인하고 싶다면 트랜잭션이 보관되어 있는 ThreadLocal 클래스에서 쉽게 찾아낼 수 있다.
이런 방법을 사용하면 메소드를 호출할 때마다 현재 실행 중인 스레드의 정보를 넘겨줘야 할 필요는 없지만 이런 방법을 사용하는 코드는 해당 프레임웍에 대한 의존성을 갖게 된다.

이렇게 편리하긴 하지만 전역 변수가 아니면서도 전역 변수처럼 동작하기 때문에 프로그램 구조성 전역 변수를 남발하는 결과를 가져올 수도 있고, 따라서 메소드에 당연히 인자로 넘겨야 할 값을 ThreadLocal을 통해
뒤로 넘겨주는 방법을 사용하면서 프로그램 구조가 허약해질 가능성도 높다.
일반적인 전역 변수가 갖는 단점처럼 ThreadLocal를 사용할 때에도 재사용성을 크게 떨어뜨릴 수 있고 객체 간에 눈에 보이지 않는 연결 관계를 만들어내기 쉽기 때뭉네 애플리케이션에 어떤 영향을 미치는지 정확하게
알고 신경 써서 사용해야 한다.

## 3.4 불변성

직접적으로 객체를 동기화하지 않고도 안전하게 사용할 수 있는 방법 가운데 마지막으로 알아볼 내용은 바로 불변 객체이다.
지금까지 살펴봤던 것 처럼 스테일 상태의 변수를 사용하게 되고, 새로 설정된 값을 사용하지 못하거나 객체가 안정적이지 않은 상태를 보게 되는 등 연산의 단일성이나 가시성에 대한 거의 모든 문제는 여러 개의 스레드가
예측할 수 없는 방향으로 변경 가능한 값을 동시에 사용하려 하기 때문에 발생한다.

불변 객체는 맨 처음 생성되는 시점을 제외하고는 그 값이 전혀 바뀌지 않는 객체를 말한다.
불변 객체의 변하지 않는 값은 처음 만들어질 때 생성 메소드에서 설정되고, 상태를 바꿀 수 없기 때문에 맨 처음 설정된 값이 나중에도 바뀌지 않는다.
불변 객체는 그 태생부터 스레드에 안전한 상태이다.

불변객체는 만들기도 쉽다.
불변 객체는 생성자가 적절하게 맞춰놓은 한 가지 상태만 유지한다.
일반적으로 프로그램 구조를 설계할 때 내부적으로 사용하는 객체가 복잡해질수록 객체가 가질 수 있는 가능한 상태들을 면밀하게 검토해야 하는 어려움이 있다.
하지만 불변 객체라면 가질 수 있는 상태가 하나뿐이기 때문에 어려운 점이 없다.

불변 객체는 안전하다.
객체 내부의 값을 바꿀 수 있다면 객체를 제 3자가 만든 코드에 넘겨주거나 외부의 라이브러리가 볼 수 있는 범위에 공개되어 있다면 굉장히 위험한 상태에 이를 수도 있다.
제3자의 코드나 외부 라이브러리가 객체 내부의 값을 변경할 수도 있고 내부 객체에 대한 참조를 보관하고 있다가 다른 스레드에서까지 객체를 임의로 가져다 쓰는 경우가 발생할 수 있다.
반대로 불변 객체는 값을 변경할 수 없기 때문에 객체의 상태 변경에 따로 대비할 필요 없이 마음껏 공개하고 공유해 사용할 수 있다.

객체 내부의 모든 변수를 final로 설정한다 해서 해당 객체가 불변이지는 않다.
변수에 참조로 연결되어 있는 객체가 불변 객체가 아니라면 내용이 바뀔 수 있기 때문이다.

불변 객체를 만족하는 조건

- 생성되고 난 이후에는 객체의 상태를 변경할 수 없다.
- 내부의 모든 변수는 final로 설정 돼야 한다.
- 적절한 방법으로 생성돼야 한다(예를 드어 this 변수에 대한 참조가 외부로 유출되지 않아야 한다.)

객체가 불변이라는 것과 참조가 불변이라는 것은 반드시 구분해서 생각해야 한다.
예를 들어 프로그램이 사용하는 데이터가 불변 객체에 들어있다 해도 해당 객체를 가리키고 있는 참조 변수에 또 다른 불변 객체를 바꿔치기 하면 프로그램의 데이터가 언제든지 바뀌는 셈이다.

### 3.4.1 final 변수

final을 지정한 변수의 값은 변경할 수 없다.
final 키워드를 적절하게 사용하면 초기화 안정성을 보장하기 때문에 별다른 동기화 작업 없이도 불변 객체를 자유롭게 사용하고 공유할 수 있다.

참조하는 객체가 불변 객체가 아니라 해도 변수를 final로 지정하면 해당 변수에 어떤 값이 들어갈 수 있는지에 대해 고려해야 할 범위가 줄어들기 때문에 프로그램을 작성할 때 편리하다.
완전한 불변 객체는 아니지만 상태 값이 하나 또는 두 개 정도로 바뀔 수 있는 거의 불변인 객체 역시 일반 객체보다는 훨씬 고려해야 할 범위를 줄여준다.
그리고 변수를 final로 선언해두면 후임자가 코드를 읽을 때에도 해당 변수에 지정된 값이 변하지 않는다는 점을 정확하게 이해할 수 있다.

### 3.4.2 불변 객체를 공개할 때 volatile 키워드 사용

서로 관련되어 있는 여러 개의 변수 값을 서로 읽거나 쓰는 과정에 경쟁 조건이 발생할 수 있는데 불변 객체에 해당하는 변수를 모두 모아두면 경쟁 조건을 방지할 수 있다.
여러 개의 변수를 묶어 사용하고자 할 때 불변 객체가 아닌 일반 객체를 만들어 사용하면 락을 사용해야 연산의 단일성을 보장할 수 있다.
하지만 불변 객체에 변수를 묶어두면 특정 스레드가 불변 객체를 사용할 때 다른 스레드가 불변 객체 값을 변경하지 않을까 걱정하지 않아도 된다.
만약 불변 객체 내부에 들어 있는 변수 값을 변경하면 새로운 불변 객체가 만들어지기 때문에 기존에 변수 값이 변경되기 전의 불변 객체를 사용하는 다른 스레드는 아무런 이상 없이 동작한다.

## 3.5 안전 공개

객체를 여러 스레드에서 공유하도록 공개해야 할 상황일 수 있는데 이럴 때는 반드시 안전한 방법을 사용해야 한다.

### 3.5.1 적절하지 않은 공개 방법

생성자가 실행되고 있는 상태의 인스턴스를 다른 스레드가 사용하려 한다면 비정상적인 상태임에도 불구하고 그대로 사용하게 될 가능성이 있고 나중에 생성 메소드가 제대로 끝나고 보니 공개한 이후에 값이 바뀐 적이 없음에도
불구하고 처음 사용할 때와는 값이 다른 경우도 생긴다.

### 3.5.2 불변 객체와 초기화 안정성

데이터를 여러 스레드가 공유하는 환경에서는 불변 객체가 굉장히 중요한 위치를 차지하기 때문에 자바 메모리 모델에는 불변 객체를 공유하고자 할 때 초기화 작업을 안전하게 처리할 수 있는 방법이 있다.
특정 객체에 대한 참조를 클래스 외부에서 볼 수 있다 해도 외부 스레드 입장에서 항상 정상적인 참조 값을 사용한다는 보장이 없다.
외부 스레드에서 항상 정상적인 값을 참조하려면 동기화 방법이 필요하다.

반면에 불변 객체를 사용하면 객체의 참조를 외부에 공개할 때 추가적인 동기화 방법을 사용하지 않았다 해도 항상 안전하게 올바른 참조 값을 사용할 수 있다.
이와 같이 안전하게 초기화 과정을 진행하려면 몇 가지 불변 객체의 요구 조건을 만족해야 한다.

1. 상태를 변경할 수 없어야 하고
2. 모든 필드의 값이 final로 선언돼야 하며
3. 적절한 방법으로 생성해야 한다.

불변 객체는 별다른 동기화 방법을 적용하지 않았다 해도 어느 스레드에서건 마음껏 안전하게 사용할 수 있다.
불변 객체를 공개하는 부분에 동기화 처리를 하지 않았다 해도 아무런 문제가 없다.

이처럼 불변 객체가 안전하다고 보장되는 내용은 올바른 방법으로 생성한 객체의 내부에 final로 선언된 모든 변수에 적용할 수 있다.
즉 final로 선언된 모든 변수는 별다른 동기화 작업 없이도 안전하게 사용할 수 있다.
하지만 final로 선언된 변수에 변경 가능한 객체가 지정되어 있다면 해당 변수에 들어 있는 값을 사용하려고 하는 부분을 모두 동기화시켜야 한다.

### 3.5.3 안전한 공개 방법의 특성

불변 객체가 아닌 객체는 모두 올바른 방법으로 안전하게 공개해야 하며 대부분은 공개하는 스레드와 불러다 사용하는 스레드 양쪽 모드에 동기화 방법을 적용해야 한다.

객체를 안전하게 공개하려면 해당 객체에 대한 참조와 객체 내부의 상태를 외부의 스레드에게 동시에 볼 수 있어야 한다. 올바른 메소드가 실행되고 난 객체는 다음과 같은 방법으로 안전하게 공개할 수 있다.

- 객체에 대한 참조를 static 메소드에서 초기화시킨다.
- 객체에 대한 참조를 volatile 변수 또는 AtomicReference 클래스에 보관한다.
- 객체에 대한 참조를 올바르게 생성된 클래스 내부의 final 변수에 보관한다.
- 락을 사용해 올바르게 막혀 있는 변수에 객체에 대한 참조를 보관한다.

Vector 객체나 synchronizedList 메소드를 사용해 동기화된 스레드 안전한 컬렉션을 만들어 객체를 만들어 객체를 보관하면 위의 방법 가운데 마지막 방법을 사용하는 셈이다.

자바에서는 다음과 같은 스레드 동기화 기능을 갖고 있다.

- Hashtable, ConcurrentMap, synchronizedMap을 사용해 만든 Map 객체를 사용하면 그 안에 보관하고 있는 키와 값 모두를 어느 스레드에서라도 항상 안전하게 사용할 수 있다.
- 객체를 Vector, CopyOnWriteArrayList, CopyOnWriteArraySet 이나 synchronizedList 또는 synchronizedSet 메소드로 만든 컬렉션은 그 안에 보관하고 있는
  객체를 어느 스레드에서라도 항상 안전하게 사용할 수 있다.
- BlockingQueue 나 ConcurrentLinkedQueue 컬렉션에 들어 있는 객체는 어느 스레드라도 안전하게 사용할 수 있다.

자바 라이브러리에서 제공하는 몇 가지 간단한 압버을 적절하게 활용해도 객체를 안전하게 공개할 수 있기 때문에 이런 방법도 객체를 안전하게 공개할 수 있는 방법이라고 할 수 있다.

static 변수를 선언할 때 직접 new 연산자로 생성 메소드를 실행해 객체를 생성할 수 있다면 가장 쉬우면서 안전한 객체 공개 방법이다.

static 초기화 방법은 JVM에서 클래스를 초기화하는 시점에 작업이 모두 진행된다.
그런데 JVM 내부에서 동기화가 맞춰져 있기 때문에 이런 방법으로 객체를 초기화하면 객체를 안전하게 공개할 수 있다.

### 3.5.4 결과적으로 불변인 객체

특정 객체를 안전한 방법으로 공개했을 경우 해당 객체에 대한 참조를 갖고 객체를 불러와 사용하는 시점에는 공개하는 시점의 객체 상태를 정확하게 사용할 수 있고 해당 객체 내부의 값이 바뀌지 않는 한 여러 스레드에서
동시에 값을 가져다 사용해도 동기화 문제가 발생하지 않는다.

기술적으로만 본다면 특정 객체가 불변일 수 없다고 해도 한 번 공개된 이후에는 그 내용이 변경되지 않는다고 하면 결과론적으로 봤을 때 해당 객체도 불변 객체라고 볼 수 있다.

### 3.5.5 가변 객체

객체의 생성 메소드를 실행한 이후에 그 내용이 변경될 수 있다면 안전하게 공개했다 하더라도 그저 공개한 상태를 다른 스레드가 볼 수 있다는 정도만 보장할 수 있다.
가변 객체를 사용할 때에는 공개하는 부분과 가변 객체를 사용하는 모든 부분에서 동기화 코드를 작성해야만 한다.
그래야 객체 내용이 바뀌는 상황을 정확하게 인식하고 사용할 수 있다.
가변 객체를 안전하게 사용하려면 안전하게 공개해야만 하고 또한 동기화와 락을 사용해 스레드 안정성을 확보해야 한다.

가변성에 따라 객체를 공개할 때 필요한 점

- 불변 객체는 어떤 방법으로 공개해도 아무 문제가 없다.
- 결과적으로 불변인 객체는 안전하게 공개해야 한다.
- 가변 객체는 안전하게 공개해야 하고 스레드 안전하게 만들거나 락으로 동기화시켜야 한다.

### 3.5.6 객체를 안전하게 공유하기
언제든 객체에 대한 참조를 가져다 사용하는 부분이 있다면 그 객체로 어느 정도의 일을 할 수 있는지를 정확하게 알고 있어야 한다.
객체를 사용하기 전에 동기화 코드를 적용해 락을 확보해야 하는지?
객체 내부의 값을 바꿔도 괜찮은지, 아니면 값을 읽기만 해야 하는 것인지?
반대로 객체를 외부에서 사용할 수 있도록 공개할 때에는 해당 객체를 어떤 방법으로 사용할 수 있고 사용하는지에 대해서 정확하게 설명해야 한다.

여러 스레드를 동시에 사용하는 병렬 프로그램에서 객체를 공유해 사용하고자 할 때 가장 많이 사용되는 원칙
- 스레드 한정 : 스레드에 한정된 객체는 완전하게 해당 스레드 내부에 존재하면서 그 스레드에서만 호출해 사용할 수 있다.
- 읽기 전용 객체를 공유 : 읽기 전용 객체를 공유해 사용한다면 동기화 작업을 하지 않더라도 여러 스레드에서 엔제든지 마음껏 값을 읽어 사용할 수 있다. 물론 읽기 전용이기 때문에 값이 변경될 수는 없다. 불변 객체와 결과적으로 불변인 객체는 읽기 전용 객체에 해당한다고 볼 수 있다.
- 스레드에 안전한 객체를 공유 : 스레드에 안전한 객체는 객체 내부적으로 필수적인 동기화 기능이 만들어져 있기 때문에 외부에서 동기화를 신경 쓸 필요가 없고, 여러 스레드에서 마음껏 호출해 사용할 수 있다.
- 동기화 방법 적용 : 특정 객체에 동기화를 적용하면 지정한 락을 획득하기 전에는 해당 객체를 사용할 수 없다. 스레드에 안전한 객체 내부에서 사용하는 객체나 공개된 객체 가운데 특정한 락을 확보해야 사용할 수 있도록 막혀 있는 객체 등에 동기화 방법이 적용되어 있다고 볼 수 있다.

# 인가 그랜트 타입
OAuth 2.0이 개발될 때 OAuth 워킹 그룹은 핵심 프로토콜을 하나의 프로토콜이 아닌 프레임워크로 취급하기로 결정했다.
프로토콜의 핵심 개념은 그대로 유지하면서 특정 영역에서는 확장을 허용해줌으로써 다양한 방식으로 OAuth 2.0 프로토콜을 적용될 수 있게 됐다.
OAuth 2.0이 달라질 수 있는 주요 영역 중 하나는 OAuth 플로라는 인가 그랜트 영역이다.
인가 코드 그랜트 타입은 OAUth 클라이언트가 인가 서버에서 토큰을 얻기 위한 여러 가지 방법 중 하나다.
인가 코드 그랜트 타입은 이미 이전에 자세히 다뤘다.

### 암시적 그랜트 타입
인가 코드 플로의 중요한 특징은 서로 다른 구성 요소 간에 정보를 별도로 유지한다는 것이다.
따라서 웹 브라우저는 클라이언트만 알아야 하는 사항을 알지 못하며, 클라이언트는 웹 브라우저의 상태 정보를 얻을 수 없다.
하지만 클라이언트가 웹 브라우저 내부에 있는 경우 클라이언트는 웹 브라우저로부터 중요한 정보를 보호할 수 없고 웹 브라우저는 클라이언트의 실행에 관련된 모든 것을 알 수 있다.
따라서 웹 브라우저를 통해 인증 코드를 클라이언트에게 전달하는 데 있어서 실질적인 이점이 없고, 클라이언트가 토큰에 대한 정보를 교환하도록 하기 위한 별도의 비밀 계층이 전혀 보호되지 않는다.

암시적 그랜트 타입은 인가 엔드 포인트에서 토큰을 직접 전달해주기 때문에 토큰 전달을 위해 사용되는 추가 비밀 정보나 상호간의 통신을 필요로 하지 않는다.
따라서 암시적 그랜트 타입은 인가 서버와의 통신을 위해 프런트 채널만 사용한다.
이 플로는 웹 사이트에 삽입돼 어느 정도 제한되고 보안 도메인 간에 공유되는 세션에 대한 인가를 수행해야 하는 자바스크립트 애플리케이션에 유용하다.

암시적 그랜트 사용 전 고려사항
- 클라이언트 시크릿을 포함한 모든 것이 웹 브라우저에게 노출되기 떄문에 클라이언트는 자신의 중요 정보를 보호할 현실적인 방법이 없다. 암시적 그랜트 플로에서는 토큰 엔드 포인트는 사용하지 않고 인가 엔드 포인트만 사용하며, 클라이언트는 인가 엔드포인트에서 인증을 받지 않는다. 따라서 이 제한은 클라이언트의 기능에 별다른 영향을 미치지 않는다. 하지만 클라이언트를 인증할 방법이 없으면 그랜트 타입에 대한 보안 프로파일에 영향을 미치게 되므로 신중하게 접근할 필요가 있다.
- 암시적 플로로는 리프레시 토큰을 얻을 수 없다.

## 클라이언트 자격 증명 그랜트 타입
명시적인 리소스 소유자가 없거나 리소스 소유자와 클라이언트 소프트웨어를 구별하기 힘들 때는 어떻게 할까?
백엔드 시스템이 있어서 그것들이 서로 직접 통신하며 특정 사용자를 대신할 필요가 없을 수 있다.
클라이언트에게 권한을 인가해줄 사용자가 없는 경우에도 OAuth를 사용할 수 있을까?

OAuth 2.0에 추가된 클라이언트 자격 증명 그랜트 타입을 이용하면 된다.

클라이언트는 인가 코드 그랜트 타입의 경우처럼 토큰 엔드 포인트에 토큰을 요청한다.
차이점은 grant_type 파라미터 값으로 client_credentials를 사용하며 토큰과 교환하기 위해 인가 코드나 임시적인 자격 증명을 사용하지 않는다.
대신 클라이언트는 직접 스스로 인증하고 인가 서버는 적절한 액세스 토큰을 발급한다.
또한 인가 코드 플로와 implicit 플로의 인가 엔드 포인트에서 사용되는 scope 파라미터와 유사하게 클라이언트는 토큰을 요청할 때 scope 파라미터를 이용해 특정 권한 범위를 요청할 수 있다.

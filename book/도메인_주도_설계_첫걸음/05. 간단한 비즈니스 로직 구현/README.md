# 간단한 비즈니스 로직 구현

비즈니스 로직은 소프트웨어에서 가장 중요한 부분이다.
하위 도메인마다 전략적 중요성과 복잡한 정도가 다르다.
이번 장에서는 단순한 비즈니스 로직에 적합한 두 가지 패턴인 트랜잭션 스크립트와 액티브 레코드에 대해 다룬다.

# 트랜잭션 스크립트

트랜잭션 스크립트 패턴은 프로시저를 기반으로 시스템의 비즈니스 로직을 구성하며 각 프로시저는 퍼블릭 인터페이스를 통해 시스템 사용자가 실행하는 작업을 구현한다.
실제로 시스템의 퍼블릭 오퍼레이션은 캡슐화의 경계로 사용된다.

## 구현

각 프로시저는 간단하고 쉬운 절차지향 스크립트로 구현한다.
저장 장치와 연동하기 위해 얇은 추상화 계층을 사용할 수 있지만 데이터베이스에 직접 접근도 가능하다.

이 프로시저가 구현해야 하는 유일안 요구사항은 트랜잭션 동작이다.
각 작업은 성공하거나 실패할 수 있지만, 유효하지 않은 상태를 만들면 안 된다.
트랜잭션 스크립트 실행이 실패하더라도 시스템은 오류가 발생할 때까지 변경사항을 롤백하거나 보상 조치를 실행하여 일관성을 유지해야 한다.
패턴의 이름처럼 스크립트에 트랜잭션 동작이 반영된다.

``` java
DB.startTransaction();

var job = DB.LoadNextJob();
var json = LoadFile(job.Source);
var xml = ConvertJsonToXml(json);

DB.commit();
```

트랜잭션 스크립트 패턴이 간단해 보여도 고급 비즈니스 로직 구현 패턴의 기반이다.
게다가 가장 틀리기 쉬운 패턴이다.

### 트랜잭션 동작 구현 실패

전체를 아우르는 트랜잭션 없이 여러 업데이트를 하는 경우다.
전체를 아우르는 트랜잭션이 없다면 시스템이 일관되지 않은 상태가 될 수 있다.
이 문제는 네트워크 중단, 데이터베이스 시간 초과 또는 교착 상태, 프로세스를 실행하는 서버의 충돌로도 발생할 수 있다.

이 문제는 전체를 아우르는 트랜잭션을 만들어서 해결할 수 있다.

관계형 데이터베이스에서 기본으로 지원하는 기능을 활용해서 여러 레코드에 걸친 트랜잭션을 쉽게 구현할 수 있다.

### 분산 트랜잭션

다중 레코드 트랜잭션을 지원하지 않는 데이터베이스에서 다중 업데이트를 하거나 분산 트랜잭션에서 통합할 수 없는 여러 개의 저장 장치로 작업하는 경우에는 상황이 복잡해진다.
최신 분산 시스템에서는 데이터베이스의 데이터를 변경한 다음 메시지 버스에 메시지를 발행하여 시스템의 다른 컴포넌트에 변경사항을 알리는 것이 일반적이다.

여러 저장 장치에 걸쳐 있는 분산 트랜잭션은 복잡하고 확장하기 어렵고 오류가 발생하기 쉬우므로 일반적으로 피하는 방식이다.

### 암시적 분산 트랜잭션

동시성 문제 또한 잠재적으로 일관성 없는 상태로 이어질 수 있는 분산 트랜잭션이다.

이 문제를 간단하게 수정하는 방법은 없다.
모두 비즈니스 도메인과 해당 요구사항에 따라 달라진다.
트랜잭션 동작을 보장하는 한 가지 방법은 작업을 멱등성으로 만드는 것이다.
이러한 문제를 해결하는 또 다른 방법은 낙관적 동시성 제어를 사용하는 것이다.

## 트랜잭션 스크립트를 사용하는 경우

트랜잭션 스크립트 패턴은 비즈니스 로직이 단순한 절차적 작업처럼 매우 간단한 문제 도메인에 효과적이다.
트랜잭션 스크립트 패턴은 정의상 비즈니스 로직이 단순한 지원 하위 도메인에 적합하다.
또한 일반 하위 도메인과 같은 외부 시스템과 연동하기 위한 어댑터로 사용하거나 충돌 방지 계층의 일부로 사용할 수도 있다.

트랜잭션 스크립트 패턴으 주요 장점은 단순함이다.
최소한의 추상화를 도입하여 런타임 성능을 최적화하고 비즈니스 로직을 이해하기 위한 시간을 최소화한다.
이러한 단순함은 패턴의 단점이 될 수도 있다.
비즈니스 로직이 복잡할수록 트랜잭션 간에 비즈니스 로직이 중복되기 쉽고 결과적으로 중복된 코드가 동기화되지 않을 때 일관성 없는 동작이 발생한다.
결과적으로 핵심 하위 도메인에는 트랜잭션 스크립트를 사용하면 안된다.
핵심 하위 도메인의 비즈니스 로직이 복잡한 경우 트랜잭션 스크립트 패턴이 대처할 수 없다는 문제점이 발생할 수 있다.

이러한 단순함으로 인해 트랜잭션 스크립트는 항상 좋다고 할 수 없으며 때로는 안티 패턴으로 취급되기도 한다.
결국 트랜잭션 스크립트로 복잡한 비즈니스 로직을 구현하면 머지않아 유지보수가 불가능한 커다란 진흙 덩어리가 될 것이다.
이러한 단순함에도 불구하고 소프트웨어 개발에서 트랜잭션 스크립트 패턴은 매우 흔하게 사용한다.

# 액티브 레코드

엑티브 레코드는 비즈니스 로직이 단순한 경우 사용한다.
그러나 액티브 레코드는 좀 더 복잡한 자료구조에서도 비즈니스 로직이 작동할 수 있다.

복잡한 자료구조의 경우 다양한 데이터들과 연관관계를 가질 수 있다.
간단한 트랜잭션 스크립트를 통해 이러한 자료구조를 조작하면 중복 코드가 많이 생성된다.

## 구현

결과적으로 이 패턴은 액티브 레코드라는 전용 객체를 사용하여 복잡한 자료구조를 표현한다.
자료구조 외에도 이러한 객체는 CRUD를 위한 데이터 접근 방법도 구현한다.
그 결과 액티브 레코드 객체는 객체 관계 매핑 또는 다른 데이터 접근 프레임워크와도 관련이 있다.
각 자료구조가 액티브하다는 점에서 패턴의 이름이 만들어졌다.
액티브 레코드는 데이터 접근 로직을 구현한다.

``` java
public class CreateUser {

    ...
    public void Execute(userDetails) {
        try {
            db.StartTransaction();
            
            var user = new User();
            user.name = userDetails.Name;
            user.Email = userDetails.Email;
            user.Save();
            db.Commit();        
        } catch {
            db.Rollback();
            throw;
        }
    }
}
```

액티브 레코드는 트랜잭션 스크립트로 비즈니스 로직을 만든다.
두 패턴의 차이점은 액티브 레코드의 경우 데이터베이스에 직접 접근하는 대신 트랜잭션 스크립트가 액티브 레코드 객체를 조작한다는 것이다.
작업이 완료되면 트랜잭션의 원자성으로 인해 작업이 성공하거나 실패한다.

이 패턴의 목적은 메모리 상의 객체를 데이터베이스 스키마에 매핑하는 복잡성을 숨기는 것이다.
영속성을 담당하는 것 외에도 액티브 레코드 객체에는 비즈니스 로직이 포함될 수 있다.
예를 들어, 필드에 할당된 새 값의 유효성을 검사하거나 객체의 데이터를 조작하는 비즈니스 관련 절차를 구현할 수 있다.
즉 액티브 레코드 객체의 고유한 기능은 자료구조와 동작의 분리다.
일반적으로 액티브 레코드의 필드에는 외부 프로시저가 상태를 수정할 수 있게 하는 퍼블릭 게터와 세터가 있다.

## 액티브 레코드를 사용하는 경우

액티브 레코드는 본질적으로 데이터베이스에 대한 접근을 최적화하는 트랜잭션 스크립트이기 때문에 이 패턴은 기껏해야 사용자 입력의 유효성을 검사하는 CRUD 작업과 같은 비교적 간단한 비즈니스 로직만 지원할 수 있다.

따라서 트랜잭션 스크립트 패턴과 마찬가지로 액티브 레코드 패턴은 지원 하위 도메인, 일반 하위 도메인과 외부 솔루션의 연동, 모델 변환 작업에 적합하다.
두 패턴의 차이점은 액티브 레코드의 경우 복잡한 자료구조를 데이터베이스에 스키마에 매핑하는 복잡성을 해소한다는 것이다.

액티브 레코드 패턴은 빈약한 도메인 모델 안티패턴이라고도 하며, 다시 말하면 부적절하게 설계된 도메인 모델이다.
비즈니스 로직이 단순할 때 액티브 레코드를 사용하는 데는 아무런 문제가 없다.
단순한 비즈니스 로직을 구현할 때보다 정교한 패턴을 사용하는 것도 우발적 복잡성을 일으켜 해를 끼칠 수 있다.

# 실용적인 접근 방식

비록 비즈니스 데이터가 중요하고 설계 및 개발되는 코드의 무결성도 보호해야 하지만 실요적인 접근 방식이 더 바람직한 몇 가지 경우가 있다.

특히 대구모로 데이터를 다루는 시스템에서는 데이터의 일관성 보장이 덜 엄격할 수 있다.
예를 들어 100만 개 중 하나의 레코드 상태를 손상시키는 것이 실제로 비즈니스에 치명적인지 그리고 비즈니스 성과와 수익성에 영향을 주는지 확인하라.

항상 그렇듯이 보편적 법칙은 없다.
그것은 작업 중인 비즈니스 도메인에 달려 있다.
앞의 예처럼 수십억 개의 이벤트 중 0.001%가 중복되거나 손실되는 일은 가능하면 무시해도 좋다.
다만 위험과 비즈니스 영향을 평가했는지 확인하라.

# 결론

비즈니스 로직을 구현하기 위한 두 가지 패턴

트랜잭션 스크립트 패턴
이 패턴은 시스템 작업을 간단하고 쉬운 절차지향 스크립트로 구성한다.
이 절차는 작업에 트랜잭션을 적용해서 작업이 성공하거나 실패하도록 보장한다.
트랜잭션 스크립트 패턴은 단순한 비즈니스 로직을 가진 지원 하위 도메인에 적합하다.

액티브 레코드
액티브 레코드
비즈니스 로직이 단순하지만 복잡한 자료구조에서 작동하는 경우 해당 자료구조를 액티브 레코드로 구현할 수 있다.
액티브 레코드 객체는 간단한 CRUD 데이터 접근 방법을 제공하는 자료구조다.

이번 장에서 논의한 두 가지 패턴은 다소 단순한 비즈니스 로직의 경우다.

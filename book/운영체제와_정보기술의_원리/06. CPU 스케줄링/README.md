CPU 버스트 : CPU를 가지고 명령을 수행하는 단계.

I/O 버스트 : I/O 요청이 발생해 커널에 의해 입출력 작업을 진행하는 단계.

# 1. CPU 스케줄러

CPU 스케줄러는 준비 상태에 있는 프로세스들 중 어떠한 프로세스에게 CPU를 할당할지 결정하는 운영체제의 코드이다.
프로세스가 CPU를 할당받고 기계어 명령을 수행하다가 타이머 인터럽트가 발생하면 CPU 스케줄러가 호출된다.
그러면 CPU는 준비 큐에서 CPU를 기다리는 프로세스 중 하나를 선택해 CPU를 할당하게 된다.

CPU 스케줄링이 필요한 대표적인 상황

- 실행 상태에 있던 프로세스가 I/O 요청 등에 의해 봉쇄 상태로 바뀌는 경우 (비선점형)
- 실행 상태에 있던 프로세스가 타이머 인터럽트 발생에 의해 준비 상태로 바뀌는 경우 (선점형)
- I/O 요청으로 봉쇄 상태에 있던 프로세스의 I/O 작업이 완료되어 인터럽트가 발생하고 그 결과 이 프로세스의 상태가 준비 상태로 바뀌는 경우 (선점형)
- CPU에서 실행 상태에 있는 프로세스가 종료되는 경우 (비선점형)

CPU 스케줄링 방식에는 비선점형 방식과 선점형 방식이 있다.
- 비선점형 방식 

CPU를 획득한 프로세스가 스스로 CPU를 반납하기 전까지는 CPU를 빼앗기지 않는 방법

- 선점형 방식

CPU를 계속 사용하기를 원하더라도 강제로 빼앗을 수 있는 스케줄링 방법으로 할당시간을 부여한 후 타이머 인터럽트를 발생시키는 방법이 대표적이다.


# 2. 디스패처
CPU 스케줄러가 어떤 프로세스에게 CPU를 할당해야 할지 결정하고나면 선택된 프로세스에게 실제로 CPU를 이양하는 작업이 필요하다. 이와 같이 새롭게 선택된 프로세스가 CPU를 할당받고 작업을 수행할 수 있도록 환경설정을 하는 운영체제의 코드를 디스패처라고 부른다.

디스패처는 현재 수행 중이던 프로세스의 문맥을 그 프로세스의 PCB에 저장하고 새롭게 선택된 프로세스의 문맥을 PCB로부터 복원한 후 그 프로세스에게 CPU를 넘기는 과정을 수행한다. 새로운 프로세스의 문맥을 복원시킨 후에는 시스템의 상태를 사용자모드로 전환해 사용자 프로그램에게 CPU의 제어권을 넘기게 된다. 그러면 사용자 프로그램은 복원된 문맥 중 프로그램 카운터로부터 현재 수행할 주소를 찾을 수 있게 된다.

디스패처가 하나의 프로세스를 정지시키고 다른 프로세스에게 CPU를 전달하기까지 걸리는 시간을 디스패치 지연시간이라고 하며 디스패치 지연시간의 대부분은 문맥교환 오버헤드에 해댱된다.

# 3. 스케줄링의 성능 평가
- CPU 이용률

전체 시간 중에서 CPU가 일을 한 시간의 비율

- 처리량

주어진 시간 동안 준비 큐에서 기다리고 있는 프로세스 중 몇 개를 끝마쳤는지를 나타낸다. 즉 CPU의 서비스를 원하는 프로세스 중 몇 개가 원하는 만큼의 CPU를 사용하고 이번 CPU 버스트를 끝내어 준비 큐를 떠났는지 측정한 것이 처리량의 개념이다.

- 소요시간

프로세스가 CPU를 요청한 시점부터 자신이 원하는 만큼 CPU를 다 쓰고 CPU 버스트가 끝날 때까지 걸린 시간 즉 준비 큐에서 기다린 시간과 실제 CPU를 사용한 시간의 합을 뜻한다.


- 대기시간

CPU 버스트 기간 중 프로세스가 준비 큐에서 CPU를 얻기 위해 기다린 시간의 합

- 응답시간

프로세스가 준비 큐에 들어온 후 첫 번째 CPU를 획득하기까지 기다린 시간

# 4. 스케줄링 알고리즘

## 1. 선입선출 스케줄링 (FCFS : First-Come First-Served)
선입선출 스케줄링은 프로세스가 준비 큐에 도착한 시간 순서대로 CPU를 할당하는 방식을 말한다.
이 방식에서는 CPU를 먼저 요청한 프로세스에게 CPU를 먼저 할당하고 그 프로세스가 자발적으로 CPU를 반납할 때까지 빼앗지 않는다.

CPU 버스트가 긴 프로세스 하나가 CPU 버스트가 짧은 프로세스 여러 개보다 먼저 도착했다면 다수의 프로세스들이 앞의 긴 작업 하나 때문에 계속 기다려야 하는 상황이 생겨 평균 대기시간이 길어지게 된다. 또한 CPU 버스트가 짧은 프로세스들에게 잠깐씩만 CPU를 할당하게 되면 이 프로세스들이 CPU 버스트를 마친 뒤 I/O 작업을 연이어 수행할 수 있는데 CPU 버스트가 긴 프로세스 하나 때문에 대기시간은 물론 I/O 장치들의 이용률까지도 동반 하락하게 된다.

## 2. 최단작업 우선 스케줄링 (SJF : Shortest-Job First)
최단작업 우선 스케줄링 알고리즘은 CPU 버스트가 가장 짧은 프로세스에게 제일 먼저 CPU를 할당하는 방식이다.
이와 같은 할당 방식을 통해 CPU 버스트가 짧은 프로세스가 CPU를 먼저 사용하고 준비 큐를 빠져나가게 되면 프로세스들이 준비 큐에서 기다리는 전체적인 시간이 줄어들게 된다. SJF 스케줄링 알고리즘은 평균 대기시간을 가장 짧게하는 최적 알고리즘으로 알려져 있다.

SJF 알고리즘은 비선점형 방식과 선점형 방식 두 가지로 구현될 수 있다.
비선점형 방식과 선점형 방식은 서로 다른 조치를 취하게 된다.
비선점형 방식에서는 현재 CPU를 점유하고 있는 프로세스가 CPU 버스트를 모두 수행하고 스스로 CPU를 내어놓을 때까지 스케줄링을 하지 않는다. 반면 선점형 방식에서는 CPU 버스트 시간이 더 짧은 프로세스가 도착하면 현재 수행 중인 프로세스에게 CPU를 선점해 CPU 버스트 시간이 더 짧은 프로세스에게 할당한다.

CPU 버스트가 짧은 프로세스가 계속 도착할 경우 CPU 버스트가 긴 프로세스는 영원히 CPU를 할당받지 못할 수도 있다. 이러한 현상을 기아 현상이라고 하며 이는 SJF 알고리즘의 심각한 문제점이다.

## 3. 우선순위 스케줄링
우선순위 스케줄링이란 준비 큐에서 기다리는 프로세스들 중 우선순위가 가장 높은 프로세스에게 제일 먼저 CPU를 할당하는 방식을 말한다. 이때 우선순위는 우선순위값을 통해 표시하며 우선순위 값이 작을수록 높은 우선순위를 가지는 것으로 가정한다. 우선순위를 결정하는 방식에는 여러 가지가 있을 수 있다.

우선순위 스케줄링도 선점형 비선점형 방식과 선점형 방식으로 각각 구현할 수 있다. 현재 CPU에서 수행 중인 프로세스보다 우선순위가 높은 프로세스가 도착하여 CPU를 선점해서 새롭게 도착한 프로세스에게 할당할 경우 선점형 방식이 된다. 이와 달리 일단 CPU를 얻었으면 비록 우선순위가 더 높은 프로세스가 도착하더라도 CPU를 자진 반납하기 전까지 선점하지 않는다면 이는 비선점형 방식이 된다.

우선순위 스케줄링 방식에서의 문제점 중 하나는 기아 현상이 발생할 수 있다는 점이다.
우선순위가 높은 프로세스가 계속 도착하는 상황에선 우선순위가 낮은 프로세스는 CPU를 얻지 못한 채 계속 기다려야 할 수 있기 때문이다. 이러한 문제점을 해결하기 위해 노화 기법을 사용할 수 있다. 노화 기법이란 기다리는 시간이 길어지면 우선순위를 조금씩 높여 언젠가는 가장 높은 우선순위가 되어 CPU를 할당받을 수 있게 해주는 방법이다.

## 4. 라운드 로빈 스케줄
라운드 로빈 스케줄링에서는 각 프로세스가 CPU를 연속적으로 사용할 수 있는 시간이 특정 시간으로 제한되며 이 시간이 경과하면 해당 프로세스로부터 CPU를 회수해 준비 큐에 줄 서 있는 다른 프로세스에게 CPU를 할당한다.
그러면 이 프로세스는 준비 큐의 제일 뒤에 가서 줄을 서 다음번 차례가 오기를 기다리게 된다.
이때 각 프로세스마다 한 번에 CPU를 연속적으로 사용할 수 있는 최대시간을 할당시간이라고 부른다.

라운드 로빈 스케줄링은 SJF 스케줄링에 비해 공정한 스케줄링 방식이라 할 수 있다.
CPU 버스트 시간을 매우 작은 단위로 나누어 실행하기 때문에 자신이 CPU를 쓰고자 하는 양이 적으면 소요시간이 짧아지고 반대로 자신이 CPU를 쓰고자 하는 양이 많으면 소요시간도 거기에 비례해서 길어진다. 대기시간 역시 자신이 사용하는 CPU 버스트 시간에 비례해 증가하므로 공정하다고 할 수 있다. 하지만 라운드 로빈 스케줄링에서 할당시간을 너무 짧게 설정하면 문맥교환의 오버헤드가 증가해 전체 시스템의 성능을 저하시킬 수 있다. 

## 5. 멀티레벨 큐
멀티레벨 큐란 준비 큐를 여러 개로 분할해 관리하는 스케줄링 기법을 말한다. 즉 프로세스들이 CPU를 가디라기 위해 한 줄로 서는 것이 아니라 여러 줄로 서는 것이다. CPU는 하나밖에 없으므로 이 경우 어떤 줄에 서 있는 프로세스를 우선적으로 스케줄링할 것인가 하는 문제가 발생한다. 또한 프로세스가 도착했을 때 어느 줄에 세워야 할지 결정하는 메커니즘도 필요하다. 멀티레벨 큐는 일반적으로 성격이 다른 프로세스들을 별도로 관리하고 프로세스의 성격에 맞는 스케줄링을 적용하기 위해 준비 큐를 별도로 두게 된다.

일번적으로 멀티레벨 큐에서 준비 큐는 대화형 작업을 담기 위한 전위 큐와 계산 위주의 작업을 담기 위한 후위 큐로 분할하여 운영된다. 전위 큐에서는 응답시간을 짧게 하기 위해 라운드 로빈 스케줄링을 사용하는 반면 계산 위주 작업을 위한 후위 큐에서는 응답시간이 큰 의미를 가지지 않기 때문에 FCFS 스케줄링 기법을 사용해 오버헤드를 줄이도록 한다.

멀티레벨 큐에서는 또 다른 스케줄링이 필요한데 이는 큐 자체에 대한 스케줄링이다. 즉 여러 개의 준비 큐에 대해서 어느 큐에 먼저 CPU를 할당할 것인지 결정하는 스케줄링이 필요한 것이다. 가장 쉬운 방법은 고정 순위 방식이다. 이 방식에서는 큐에 고정적인 우선순위를 부여해 우선순위가 높은 큐를 먼저 서비스하고 우선순위가 낮은 큐는 우선순위가 높은 큐가 비어 있을 때에만 서비스하게 된다. 고정 우선순위 방식 외에 타임 슬라이스 방식을 사용할 수도 있다. 이 방식은 큐에 대한 기아 현상을 해소할 수 있는 방식으로 각 큐에 CPU 시간을 적절한 비율로 할당한다.

## 6. 멀티레벨 피드백 큐
멀티레벨 피드백 큐는 CPU를 기다리는 프로세스를 여러 큐에 줄 세운다는 측면에서 멀티레벨 큐와 동일하나 프로세스 하나가 큐에서 다른 큐로 이동 가능하다는 점이 다르다. 멀티레벨 피드백 큐는 프로세스들의 다양한 성격을 반영해 구현할 수 있다. 예를 들면 우선순위 스케줄링에서 기아현상을 해결하기 위한 노화 기법을 멀티레벨 피드백 큐 방식으로 구현할 수 있다. 우선순위가 낮은 큐에서 오래 기다렸으면 우선순위가 높은 큐로 승격시키는 방식이다.

멀티레벨 피드백 큐를 정의하는 요소들로는 큐의 수, 각 큐의 스케줄링 알고리즘, 프로세스를 상위 큐로 승격시키는 기준, 프로세스를 하위 큐로 강등시키는 기준, 프로세스가 도착했을 때 들어갈 큐를 결정하는 기준 등이 있다.

